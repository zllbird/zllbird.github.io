<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>开发 on Coder-bird </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://zllbird.github.io/categories/%E5%BC%80%E5%8F%91/</link>
    <language>en-us</language>
    <author>诸隆隆</author>
    <copyright>© 2015 Copyright Text</copyright>
    <updated>Mon, 23 Nov 2015 16:49:45 CST</updated>
    
    <item>
      <title>Android自定义属性使用</title>
      <link>https://zllbird.github.io/2015/11/23/android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 23 Nov 2015 16:49:45 CST</pubDate>
      <author>诸隆隆</author>
      <guid>https://zllbird.github.io/2015/11/23/android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8/</guid>
      <description>

&lt;h1 id=&#34;android自定义属性使用以及注意事项:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;Android自定义属性使用以及注意事项&lt;/h1&gt;

&lt;p&gt;自定义控件和自定义属性是安卓开发过程中实现个性化的一个很好技巧，也是对sdk中UI部分的使用更加灵活的部分。这部分主要实现自定义属性，自定义控件的文档正在完善中。&lt;/p&gt;

&lt;h3 id=&#34;如何实现:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;如何实现：&lt;/h3&gt;

&lt;h4 id=&#34;a-在配置文件中声明:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;a) 在配置文件中声明。&lt;/h4&gt;

&lt;p&gt;虽说在value中哪个文件里都是一样（保证在resources标签下就行)，但作为一个有志向的开发者，良好的文件管理习惯是必须的，so，在values中创建一个名为：&lt;code&gt;attrs.xml&lt;/code&gt;来统一管理自定义属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;resources&amp;gt;
  &amp;lt;declare-styleable name=&amp;quot;ImageTextView&amp;quot;&amp;gt;
        &amp;lt;attr name=&amp;quot;select_src&amp;quot; format=&amp;quot;reference&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;normal_src&amp;quot; format=&amp;quot;reference&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;select_text_color&amp;quot; format=&amp;quot;color&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;normal_text_color&amp;quot; format=&amp;quot;color&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;image_text_padding&amp;quot; format=&amp;quot;dimension&amp;quot;/&amp;gt;
        &amp;lt;attr name=&amp;quot;android:textSize&amp;quot;/&amp;gt;
        &amp;lt;attr name=&amp;quot;android:layout_gravity&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;android:text&amp;quot; /&amp;gt;
    &amp;lt;/declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义属性的声明是通过子标签&lt;code&gt;declare-styleable&lt;/code&gt;声明了大的样式，具体的属性是通过&lt;code&gt;attr&lt;/code&gt;来声明，声明包含属性名和格式（具体是属性值的格式，一般有reference，color，integer，float，dimension，boolean，string等，当然还有enum，如果是枚举的话要继续声明具体的枚举），如果对于自定义控件来说，某些属性就是已经android声明的属性，就可以在&lt;code&gt;name&lt;/code&gt;后面直接写明使用android：声明的哪个属性（简单吧）。&lt;/p&gt;

&lt;h4 id=&#34;b-在自定义控件xml中使用:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;b) 在自定义控件xml中使用&lt;/h4&gt;

&lt;p&gt;（主要是讲解自定义属性，所以这里的自定义控件较为简单，就是一个imageview + textview的组合）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;com.android.lesdo.view.UpImageTextView
	//声明使用app来定义自定义属性名，当然这个命名是你确定的。
    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    android:id=&amp;quot;@+id/iv&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text = &amp;quot;Hello&amp;quot;
    android:textSize = &amp;quot;14sp&amp;quot;
    android:layout_marginRight=&amp;quot;59dp&amp;quot;
    // 使用刚才已经在arrts里声明好的属性
    app:select_src = &amp;quot;@drawable/searchuser_t_pressed&amp;quot; 
    app:normal_src = &amp;quot;@drawable/searchuser_t_normal&amp;quot;
    app:select_text_color = &amp;quot;@color/green&amp;quot;
    app:normal_text_color = &amp;quot;@color/content&amp;quot;
    app:image_text_padding = &amp;quot;7dp&amp;quot;
    /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以声明android本来的属性，一样可以使用（具体在自定义控件里说明）。&lt;/p&gt;

&lt;h4 id=&#34;c-在自定义控件-java类-中读取属性使用:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;c) 在自定义控件（java类）中读取属性使用&lt;/h4&gt;

&lt;p&gt;最后的使用。&lt;/p&gt;

&lt;p&gt;自定义控件大多数要继承原本的&lt;code&gt;Imageview&lt;/code&gt; ，&lt;code&gt;TextView&lt;/code&gt; ，&lt;code&gt;FrameLayout&lt;/code&gt;等，当然直接继承View也是一样的，只不过直接继承View和ViewGroup的灵活性太高，一般用不到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public UpImageTextView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    // 加载布局文件
    LayoutInflater.from(context).inflate(R.layout.down_text_image,this);
        imageView = (ImageView) findViewById(R.id.image);
        textView = (TextView) findViewById(R.id.text);

    // 获取属性集
  	// 这里获取的就是我们再res 下value中声明的ImageTextView属性集
  	// 当然是由IDE自动在R文件中生成的。
        final TypedArray a = context.obtainStyledAttributes(
                attrs, R.styleable.ImageTextView);

    // 通过声明的format 就可以定向获取到属性
  	// R.styleable 都是自动生成的，具体属性名都是跟在声明的style名字后面的
  	// R.styleable.ImageTextView_normal_src对应的就是 arrts.xml中的
  	// &amp;lt;attr name=&amp;quot;normal_src&amp;quot; format=&amp;quot;reference&amp;quot; /&amp;gt;

       int selectRes = a.getResourceId(R.styleable.ImageTextView_select_src,0);
       int normalRes = a.getResourceId(R.styleable.ImageTextView_normal_src,0);
       int selectTextColor = a.getResourceId(R.styleable.ImageTextView_select_text_color,R.color.green);
       int normalTextColor = a.getResourceId(R.styleable.ImageTextView_normal_text_color, R.color.title);
      int textSize = a.getDimensionPixelSize(R.styleable.ImageTextView_android_textSize, 0);
        int image_text_padding = a.getDimensionPixelOffset(R.styleable.ImageTextView_image_text_padding,0);
        String text = a.getString(R.styleable.ImageTextView_android_text);

        a.recycle();
        imageView.setImageResource(normalRes);
        textView.setTextColor(getResources().getColor(normalTextColor));
        textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
        textView.setText(text);
        textView.setPadding(0,image_text_padding,0,0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依次获取属性，然后使用。弹药注意的是，获取完自定义或者本身的属性后，一定要将&lt;code&gt;final TypedArray a&lt;/code&gt;返回到用之前的状态，可以看到&lt;code&gt;TypedArray&lt;/code&gt;是context中获取的，它是一个环境中统一使用的，所以用完记得要还。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; a.recycle();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的坑：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; int textSize = a.getDimensionPixelSize(R.styleable.ImageTextView_android_textSize, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里获取的 ，单位是&lt;strong&gt;sp&lt;/strong&gt;得值 ，单位是&lt;strong&gt;sp&lt;/strong&gt;得值 ，单位是&lt;strong&gt;sp&lt;/strong&gt;得值！！！&lt;/p&gt;

&lt;p&gt;所以使用的时候记得加上&lt;code&gt;TypedValue&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android Transition 学习心得</title>
      <link>https://zllbird.github.io/2015/11/12/android-transition-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</link>
      <pubDate>Thu, 12 Nov 2015 15:40:32 CST</pubDate>
      <author>诸隆隆</author>
      <guid>https://zllbird.github.io/2015/11/12/android-transition-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</guid>
      <description>

&lt;h1 id=&#34;android-transition-学习心得:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Android Transition 学习心得&lt;/h1&gt;

&lt;p&gt;Android 5.0之后。Transition 被更多的应用起来，support也对其越来越多得支持。这种大背景下，各种动画的学习便是必不可少的了。而其中Transition便是其中的佼佼者。&lt;/p&gt;

&lt;p&gt;下面是比较详细的介绍和应用实践，我也是主要通过这个项目学习，但强烈建议，只先通看文档，别上来直接就照着写（还有看完后，记得回来啊！！！）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lgvalle/Material-Animations&#34;&gt;Material-Animations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看完后，我那叫一个心血澎湃。但按住心情，现在才是真正意义上的开始学习。&lt;/p&gt;

&lt;p&gt;我学习的过程，大概分以下几部分，可以做个参考，也非常欢迎大家的质疑和讨论。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先运行Demo或者Examples代码，运行结果ok后，认真研读代码。&lt;em&gt;我始终认为，读一个轻量，但完整的工程代码，是快速学习的最有效的途径&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;对关键API(类和方法)的学习。&lt;em&gt;知其然，也必须，知其所以然&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;尝试代码。&lt;em&gt;写代码千万不要粘贴，千万不要忘记配置文件，android中千万不要忘记style等&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;activity跳转:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Activity跳转&lt;/h3&gt;

&lt;h4 id=&#34;1-activity跳转都是需要添加-window-属性:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;1)Activity跳转都是需要添加&lt;code&gt;window&lt;/code&gt;属性。&lt;/h4&gt;

&lt;p&gt;配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;style name=&amp;quot;MaterialAnimations&amp;quot; parent=&amp;quot;@style/Theme.AppCompat.Light.NoActionBar&amp;quot;&amp;gt;
  ...
  //添加window开启Transtions动画属性
  &amp;lt;item name=&amp;quot;android:windowContentTransitions&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt; 

  //是否覆盖执行，其实可以理解成是否同步执行还是顺序执行
  &amp;lt;item name=&amp;quot;android:windowAllowEnterTransitionOverlap&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
  &amp;lt;item name=&amp;quot;android:windowAllowReturnTransitionOverlap&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
  ...
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以直接在代码里写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过不建议在代码里写，因为现在使用Support v7 比较多，所以，不是直接原生的Activity，会又很多莫名其妙的错误。&lt;/p&gt;

&lt;h4 id=&#34;2-配置进出动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;2)配置进出动画&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void setupWindowAnimations() {
    // Re-enter transition is executed when returning to this activity
    Slide slideTransition = new Slide();
    slideTransition.setSlideEdge(Gravity.LEFT);
 slideTransition.setDuration(getResources().getInteger(R.integer.anim_duration_long));
    getWindow().setReenterTransition(slideTransition); // 5.0以后的方法
    getWindow().setExitTransition(slideTransition); // 5.0以后的方法
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-启动页面跳转:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;3)启动页面跳转&lt;/h4&gt;

&lt;p&gt;这里需要注意的跳转的时候&lt;strong&gt;一定一定一定&lt;/strong&gt;要配置ActivityOption。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 配置这个option必不可少
ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity,view,shareName);
startActivity(intent,options.toBundle());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，现在用support已经成为主流，下面是v4提供的支持类，用法相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 配置这个option必不可少
ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity,view,shareName);
startActivity(intent,options.toBundle());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，基本Activity的跳转就实现了。官方提供了三种实践，&lt;strong&gt;Explode&lt;/strong&gt;, &lt;strong&gt;Slide&lt;/strong&gt; 和&lt;strong&gt;Fade&lt;/strong&gt;，分别是上下拉开，上下左右滑入滑出，以及淡出淡入等。&lt;/p&gt;

&lt;h3 id=&#34;shareelement共享元素:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;ShareElement共享元素&lt;/h3&gt;

&lt;p&gt;不同界面的相同元素，进行跳转的时候，共联跳转，看起来简直是舒服到不行。也是我学习TransitionAnimation最大的动力。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lgvalle/Material-Animations&#34;&gt;Material-Animations&lt;/a&gt;中有非常详细的介绍实现。&lt;/p&gt;

&lt;p&gt;我整体试了一下，发觉使用&lt;code&gt;Fragment&lt;/code&gt;比使用&lt;code&gt;Activity&lt;/code&gt;动画不仅连贯很多，而且整体感更强。而且，&lt;code&gt;Fragment&lt;/code&gt;的API对Transtion更加的亲善。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Transition for fragment1
Slide slideTransition = new Slide(Gravity.LEFT); 
slideTransition.setDuration(getResources().getInteger(R.integer.anim_duration_long));
// Create fragment and define some of it transitions
SharedElementFragment1 sharedElementFragment1 = SharedElementFragment1.newInstance(sample);
// 下面这几个方法都是Fragment的方法，可见Google已经建议使用Fragment，进行共享元素跳转是相当好的体验
sharedElementFragment1.setReenterTransition(slideTransition); 
sharedElementFragment1.setExitTransition(slideTransition);
sharedElementFragment1.setSharedElementEnterTransition(new ChangeBounds());

getSupportFragmentManager().beginTransaction()
        .replace(R.id.sample2_content, sharedElementFragment1)
        .commit();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google建议，使用Fragment去承载UI界面，Activity主要承载操作Fragment。因此，关于跳转，也强烈建议使用上面的实践。&lt;/p&gt;

&lt;h3 id=&#34;view动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;View动画&lt;/h3&gt;

&lt;h4 id=&#34;scenes:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Scenes&lt;/h4&gt;

&lt;p&gt;在一个界面内（Activity or Fragment）实现动画，就需要&lt;code&gt;scenes&lt;/code&gt;，这个scene，翻译成视图，结果图都觉得很别扭，我就这么解释，scene是一种静态或者结果状态，就是最后是啥样子的。如果是位移动画，相当于初始位置的图，和运动完后的位置图。然后由，&lt;code&gt;TransitionManager&lt;/code&gt;最后调用，go方法，他就跑起来了。&lt;/p&gt;

&lt;p&gt;详细请看项目中的&lt;code&gt;AnimationsActivity2&lt;/code&gt;类，核心代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cene1 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene1, this);
scene2 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene2, this);
scene3 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene3, this);
scene4 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene4, this);

View button1 = findViewById(R.id.sample3_button1);
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene1, new ChangeBounds());
    }
});
View button2 = findViewById(R.id.sample3_button2);
button2.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene2, TransitionInflater.from(AnimationsActivity2.this).inflateTransition(R.transition.slide_and_changebounds));
    }
});

View button3 = findViewById(R.id.sample3_button3);
button3.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene3, TransitionInflater.from(AnimationsActivity2.this).inflateTransition(R.transition.slide_and_changebounds_sequential));
    }
});

View button4 = findViewById(R.id.sample3_button4);
button4.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene4, TransitionInflater.from(AnimationsActivity2.this).inflateTransition(R.transition.slide_and_changebounds_sequential_with_interpolators));
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;view-属性改变引起的动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;View 属性改变引起的动画&lt;/h4&gt;

&lt;p&gt;这个就有点变态了，你更改了空间的layout属性，告诉Transtion一声，他就做成动画反馈在界面上。听起来就很叼！&lt;/p&gt;

&lt;p&gt;实现起来非常非常的简单，简单到想哭。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void changeLayout() {

  // 声明，由Transition接管界面变化的意思，这里的viewRoot相当于根视图，
  // 也就是说，想改变layout布局的view,父类要先被接管
    TransitionManager.beginDelayedTransition(viewRoot);

    ViewGroup.LayoutParams params = square.getLayoutParams();
    if (sizeChanged) {
        params.width = savedWidth;
    } else {
        savedWidth = params.width;
        params.width = 200;
    }
    sizeChanged = !sizeChanged;
    square.setLayoutParams(params);
}

private void changePosition() {
    TransitionManager.beginDelayedTransition(viewRoot);

    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) square.getLayoutParams();
    if (positionChanged) {
        lp.gravity = Gravity.CENTER;
    } else {
        lp.gravity = Gravity.LEFT;
    }
    positionChanged = !positionChanged;
    square.setLayoutParams(lp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信，介于此，5.0后的android上很多用户体验能提升一大截。&lt;/p&gt;

&lt;h3 id=&#34;reveal-揭示动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Reveal，揭示动画&lt;/h3&gt;

&lt;p&gt;这也是相当符合设计一种动画，通过一点引发触动（可以是接触点，也可以位移后触动），然后由点及面，揭示（展现）内容。&lt;/p&gt;

&lt;p&gt;一般都是通过shared elements一起组合使用，完成界面跳转。&lt;/p&gt;

&lt;p&gt;Circular Reveal 即通过原点，然后由点及面逐步揭示，而且还有一个弧度，视觉体验感非常好。&lt;/p&gt;

&lt;p&gt;这里要用到&lt;code&gt;ViewAnimationUtils&lt;/code&gt;类（这个类里承载了很多动画，非常还用!）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 揭示原点，这里的点取的是控件的中点
int cx = (viewRoot.getLeft() + viewRoot.getRight()) / 2;
int cy = (viewRoot.getTop() + viewRoot.getBottom()) / 2;
int finalRadius = Math.max(viewRoot.getWidth(), viewRoot.getHeight()); // 揭示弧度

// 获得动画
Animator anim = ViewAnimationUtils.createCircularReveal(viewRoot, cx, cy, 0, finalRadius);

// 这里更改动画，是为了看到的揭示能比较清楚
viewRoot.setBackgroundColor(color);
anim.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        animateButtonsIn();
    }
});
anim.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不是由控件引起的，而是由点击（其实就是触摸）引起的，只需要传入接触点的x,y坐标就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public boolean onTouch(View view, MotionEvent motionEvent) {
    if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
        if (view.getId() == R.id.square_yellow) {
            revealFromCoordinates(motionEvent.getRawX(), motionEvent.getRawY());
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Animator animateRevealColorFromCoordinates(int x, int y) {

    float finalRadius = (float) Math.hypot(viewRoot.getWidth(), viewRoot.getHeight());

    Animator anim = ViewAnimationUtils.createCircularReveal(viewRoot, x, y, 0, finalRadius);
    viewRoot.setBackgroundColor(color);
    anim.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刚才提到的改变layout属性，就可以改变动画其实也是可以用到圆揭示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Transition transition = TransitionInflater.from(this).inflateTransition(R.transition.changebounds_with_arcmotion);
transition.addListener(new Transition.TransitionListener() {
    @Override
    public void onTransitionEnd(Transition transition) {
        animateRevealColor(bgViewGroup, R.color.red);
    }
    (...)

});
//接管后，传入想要改变的动画
TransitionManager.beginDelayedTransition(bgViewGroup, transition);
RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT);
btnRed.setLayoutParams(layoutParams);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;总结:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;写的比较简单，很多东西还是对API的熟悉和使用。&lt;/p&gt;

&lt;p&gt;Material 正在改变Android，相信以后的UI无论从实感还是物理感，都会更加贴合用户，贴近使用。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Git清理误传的文件</title>
      <link>https://zllbird.github.io/2015/11/11/git%E6%B8%85%E7%90%86%E8%AF%AF%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 11 Nov 2015 09:53:37 CST</pubDate>
      <author>诸隆隆</author>
      <guid>https://zllbird.github.io/2015/11/11/git%E6%B8%85%E7%90%86%E8%AF%AF%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
      <description>

&lt;h1 id=&#34;git清理误传的文件:2c3299dc152aba749c72550a3d365541&#34;&gt;Git清理误传的文件&lt;/h1&gt;

&lt;p&gt;​   Git进行版本管理的时候，项目中很多文件(配置文件，自动生成文件，构建生成文件，依赖包等)是不需要同步上传到服务器。一方面，造成文件的多余，另一方面，如本地配置文件（&lt;code&gt;local.properties&lt;/code&gt;），不同人员的来回提交，则会造成同步开发人员的版本混乱——不断地解决重复冲突，这是相当不值得的。&lt;/p&gt;

&lt;p&gt;​   Git提供了一种忽略机制——gitignore。本质上也是一种Git配置，类似于配置文件。将配置文件中相关文件忽略，写法与Android工程是熟悉的混淆配置文件（&lt;code&gt;proguard-rules.pro&lt;/code&gt;）非常相似。功能也是将&lt;code&gt;.gitignore&lt;/code&gt;里面配置好的文件忽略，或者说是剔除，不让此文件加入版本控制。&lt;/p&gt;

&lt;p&gt;​   关于gitignore的详细介绍请&lt;a href=&#34;http://git.oschina.net/progit/&#34;&gt;参考这里,第二章基础&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​   显然，对于我这种Git新手，很可能知道这些的时候，已经把配置文件都扔到服务器上了。然后，一阵胡搞乱搞…（都是满纸辛酸泪），其实根本原因还是对Git本身理解不够。接下来，简单介绍一下做法，以及远离。&lt;/p&gt;

&lt;p&gt;​   解决步奏：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将配置文件文件名（如&lt;code&gt;local.properties&lt;/code&gt;）放到.gitignore里。&lt;/li&gt;
&lt;li&gt;检查工作空间里是否还有这个文件（如，在配置文件里随便改点，然后，git status检查工作空间里是否存在）&lt;/li&gt;
&lt;li&gt;如果不存在，你可以关掉网页了。如果存在，备份，然后删除它！！！（直接在shell里rm）&lt;/li&gt;
&lt;li&gt;然后 add , commit ,push 一套走下来。&lt;/li&gt;
&lt;li&gt;查看远程git服务器端也没有这个文件。&lt;/li&gt;
&lt;li&gt;然后，把刚才备份的文件拿回来。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;写到这，突然觉得自己好无聊啊好无聊，这么特么的不就是删了就完了。好吧，我承认，这就是&amp;hellip;&lt;/p&gt;

&lt;p&gt;接下来说说我的理解，Git的版本控制其实本质上是对文件的操作跟踪。所以，一旦进入了版本控制，跟踪系统就会去记录它（这个文件）上发生的所有操作，即便把它放到忽略文件里也同样。因为忽略是晚于跟踪的，也就是说，只有未被跟踪的文件才有被忽略的权利。&lt;/p&gt;

&lt;p&gt;下面是 git status 中对于修改的文件和刚刚加入的文件的显示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/git-untruck.png&#34; alt=&#34;git-untruck&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候，上面两个文件是无法被忽略的，而add.txt，是可以被忽略的。&lt;/p&gt;

&lt;p&gt;这也刚才我们必须先删除，再拿回来的原因。&lt;/p&gt;

&lt;p&gt;附上Android常用的.gitgnore。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# built application files
*.ap_

# files for the dex VM
*.dex
*.iml

# Java class files
*.class

# generated files
bin/
gen/
*target/
*build/
*build*
.gradle/
.idea/

gen-external-apklibs/

# Local configuration file (sdk path, etc)
/library_wheel/build
local.properties

# Eclipse project files
.classpath
.project

# Mac os
.DS_Store

# DEBUG
captures/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
