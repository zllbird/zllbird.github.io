<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>思考 on Coder-bird</title>
    <link>https://zllbird.github.io/categories/%E6%80%9D%E8%80%83/</link>
    <description>Recent content in 思考 on Coder-bird</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2015 Copyright Text</copyright>
    <lastBuildDate>Mon, 30 May 2016 19:50:43 +0800</lastBuildDate>
    <atom:link href="https://zllbird.github.io/categories/%E6%80%9D%E8%80%83/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>必然，重混和互动</title>
      <link>https://zllbird.github.io/2016/05/30/%E5%BF%85%E7%84%B6%E9%87%8D%E6%B7%B7%E5%92%8C%E4%BA%92%E5%8A%A8/</link>
      <pubDate>Mon, 30 May 2016 19:50:43 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/05/30/%E5%BF%85%E7%84%B6%E9%87%8D%E6%B7%B7%E5%92%8C%E4%BA%92%E5%8A%A8/</guid>
      <description>

&lt;h2 id=&#34;必然-重混和互动:c88345bce496b846535b1a0b38761f7d&#34;&gt;必然,重混和互动&lt;/h2&gt;

&lt;h3 id=&#34;创新不一定是创造:c88345bce496b846535b1a0b38761f7d&#34;&gt;创新不一定是创造&lt;/h3&gt;

&lt;p&gt;一直有个误区，以为创新就是从无到有。必然这章，让我重新定义创新的意思，为了区别我原来对于创新这个词的理解。就先把从无到有的这个过程叫做创造吧。
难道创新不是从无到有吗？不全是，是一部分，准确的讲，应该是一小部分。从无到有是一件很不容易的事情，依我看来，非大能力者和大毅力者不能为之。但创新不仅仅是这部分难的，也有一部分简单的，将已经有的东西，拆分打乱，然后重新组合，重混成一个崭新的事物。不是从无到有，但一样满满的全是新的，这不就是一种创新。
那么，道理谁都会讲，问题是，该怎么做？&lt;/p&gt;

&lt;h3 id=&#34;从目录说起:c88345bce496b846535b1a0b38761f7d&#34;&gt;从目录说起&lt;/h3&gt;

&lt;p&gt;必然书中，给了一个强力的例子，当我读到这的时候，莫得有一种心有戚戚的感觉。目录对于书来首，绝对是伟大的创造。让亿万书目从此有了检索。当然，对于此完全可以写一篇文章专门来歌颂，但今天不是来夸它的。&lt;/p&gt;

&lt;p&gt;如今的网络时代，文字这个载体依然在这个平台上呼啸嘚瑟，但较比千年，它已经出现了形形色色的对手。图片，声音，视频正不断的扩大着，毕竟数字时代，很多以前只能靠文字和书来承接的，现在都可以通过多媒体来，而且更加可观，更加优秀。但即便如此，仍有些东西还未完善，比如目录。&lt;/p&gt;

&lt;p&gt;如果把书对比与电影。那么，目录对于书，什么对于电影呢？关键位置的截图吗？还是预告片？我们读一本书的目录能了解到这本书整体的结构，而电影呢？只看预告片足够吗？或者看关键位置的截图（相信经常看日本爱情动作片的孩子，应该能明白我想说的是什么）？其实不足够，技术还需要发展，文字已经发展到可以通过搜索引擎来检阅目录和关键字来定位到书中的具体位置，可搜索对于图片和视频仍然是进行困难。&lt;/p&gt;

&lt;p&gt;先把困难放在一边。如果google能搜索音乐和电影里的具体内容，我们是否可以想象，当我们需要一个场景的时候，我们告诉google我们想要一个什么场景的片段，然后所有相近和相似的片段都会出现供我选择。想一下还挺兴奋的。&lt;/p&gt;

&lt;h3 id=&#34;时间不可逆吗:c88345bce496b846535b1a0b38761f7d&#34;&gt;时间不可逆吗？&lt;/h3&gt;

&lt;p&gt;时间是最大最不可能回退的成本，也是最廉价的成本。因为它不可保存，只能使用掉或者浪费掉。但反过来想，真的如此吗？数字技术，已经很大程度，或者说，另类的实现了这种替代。编辑文本时时时撤销，从任何一个保存的节点再重新开始写。视频和图片软件同样，游戏软件更加是如此。仍记得，当初玩《仙剑奇侠传》时，挂掉之后就会出现一排字：胜败乃兵家常事，大侠请重新来过吧。时间不可逆，但我们却可以重新来过，我们再改变时间吗？&lt;/p&gt;

&lt;p&gt;时间悖论很多，也太过于光怪陆离，但无论哪个版本，能回看自己的历经，那将是一种什么状体？读书读到这里的时候，我猛地想起来一部英剧——黑镜。&lt;/p&gt;

&lt;h3 id=&#34;vr-虚拟现实-还是从智能说起吧:c88345bce496b846535b1a0b38761f7d&#34;&gt;VR?虚拟现实？还是从智能说起吧&lt;/h3&gt;

&lt;p&gt;这两年VR被炒得太热了，我读到这的时候，没多大热情和兴趣。只有一个小小的猜测，虚拟现实技术，我预想真正带动它发展的，应该是网络色情服务。它是最能带来互动，但却不需要很多智能的互动的行业，我们拭目以待吧。&lt;/p&gt;

&lt;p&gt;互动这章也很有意思，一直在努力提供一种思路。我们使用各种电子设备，达到一种感受。但使用本身是相互的，越进步，就越相互，是一种相互满足的状态。或许，我们一直追求的智能，本来就应该是一种互动的概念，我读一本书时，我遇到一个不懂得词语时，不应该需要我去查询，甚至不需要我用手点一下屏幕，书和屏幕就自动显示这个词语的意思以及维基上的解释。（这并不困难，只要让屏幕读懂我们皱眉，我们抿嘴，我们&amp;hellip;总之，我们总会出现什么被捕捉到）这才是互动，或者，这才配得上智能二字。&lt;/p&gt;

&lt;p&gt;突然间脑洞一点点，人们总是歌舞，歌舞，但总是先有歌，然后编排舞步，有没有一种方式，让我在房间里自由自在的舞动，房间里的设备捕捉到我舞动的感觉，然后出来一首动听配合舞蹈的歌曲呢？&lt;/p&gt;

&lt;p&gt;互动代表它有一种智慧在里面，即便是略显机械的智慧，仍让我们觉得它是活的那种感觉，而这种感觉恰恰就是人们离不开的东西。&lt;/p&gt;

&lt;p&gt;我们头戴着头盔，单靠意识去让我们的机械手臂拿起东西来，更高级的，让我们能隔空取物&amp;hellip;然后，我又在想，如果这样，那么头戴着头盔，让我们能用意识控制电脑，打开文件，移动鼠标，打字&amp;hellip;这两种，切不论哪个更难实现，反过来想问问自己，哪个以后更为常见呢？又是那个问题，我们到时候是更多在乎所谓的现实世界，还是更多在乎所谓的数字世界呢？我觉得，很可能更在乎的是数字世界，就我而言，更在乎用意识控制电脑打字出来，想想就激动的忍不住颤抖。&lt;/p&gt;

&lt;p&gt;还有一点。互动的成本，或者说，任何技术带来的学习成本。学习是有成本的，这个成本还不是定额的，就现在而言，我所知道的，年龄和阅历会让这个成本变得无法估计。所以，实现技术是一件事儿，普及还是一件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>必然，我们在选择，也在被选择</title>
      <link>https://zllbird.github.io/2016/05/29/%E5%BF%85%E7%84%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E9%80%89%E6%8B%A9%E4%B9%9F%E5%9C%A8%E8%A2%AB%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sun, 29 May 2016 15:11:30 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/05/29/%E5%BF%85%E7%84%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E9%80%89%E6%8B%A9%E4%B9%9F%E5%9C%A8%E8%A2%AB%E9%80%89%E6%8B%A9/</guid>
      <description>

&lt;h1 id=&#34;必然-我们在选择-也在被选择:1c3125473ed37800649884e0f74ea659&#34;&gt;必然，我们在选择，也在被选择。&lt;/h1&gt;

&lt;h3 id=&#34;摘要:1c3125473ed37800649884e0f74ea659&#34;&gt;摘要&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;相见恨晚&lt;/li&gt;
&lt;li&gt;我就是我，是颜色不一样的烟火&lt;/li&gt;
&lt;li&gt;时间是个伪命题，但注意力是真命题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;必然之必然，KK的这本书的确有很多角度让我折服。离开固有的想法不易，但重新解读固有的想法似乎更难。&lt;/p&gt;

&lt;h3 id=&#34;相见恨晚:1c3125473ed37800649884e0f74ea659&#34;&gt;相见恨晚&lt;/h3&gt;

&lt;p&gt;必然中专门讲了亚马逊的推荐，读书或者书目推荐，既然是读书。
那从读书讲起。
经常读书，最开心的莫过于读到一本好书，同理，不开心的也是读了半天才发觉是一本烂书。自然，选书一直是我的难题，而且越来越难，因为时间越来越少。每每读到一本好书的时候，总有那么一种&lt;strong&gt;相见恨晚&lt;/strong&gt;的感觉。自然，找到一本好书不易，找到一本一见如故，很对自己口味的好书更是难上加难，选书真的是一件很技术的活，&lt;strong&gt;直到&lt;/strong&gt;亚马逊的出现。&lt;/p&gt;

&lt;p&gt;*亚马逊的那个功能————购买这本书的用户，同时还购买了这几本书。*亚马逊的推荐真的是拯救了我，刚开始的时候我只是尝试的买了几本系统推荐给我的书，但随后便一发不可收拾，那种&lt;strong&gt;相见恨晚&lt;/strong&gt;的感觉一次接一次的，书荒已成历史。（此处让我先美一会儿）&lt;/p&gt;

&lt;p&gt;这个世界上，总有一些人和我喜欢一样的书，有着相似的历经，自然也会有着相似的书目，如果我们能相聚在一起，开个读书分享会，交换有无，将彼此读过的书分享出来，每次读书会结束，我都能收获一些新的书目，享受一段新的读书时光。以前，这是一个奢望，毕竟找到志同道合的人，然后相聚是一件多么需要巧合的事情，但在现在，它已经不需要了，数据洪流中，我们已经公开了分享了自己的书目，甚至分享了自己的品味和思考（只是我们并不自知），亚马逊将这些计算完，汇成一个标签，然后找到相同标签的人，将这些书目放到我们面前。&lt;strong&gt;至此，我跨过了我的奢望。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;替亚马逊做完广告。当我读必然读完这段的时候，我脑子里一直有这么一个想法。既然，志同道合能让数据推荐给我好书，那同仇敌忾是否也一样可以呢？比如，亚马逊的书下面有那么一个选项，喜欢/讨厌，供我选择。然后，在下次登录时，讨厌这本书的用户，都比较喜欢这几本书或者讨厌这本书的用户同时也讨厌这几本书。如此一来，岂不更有意思。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;志同道合是理由，那同仇敌忾也是。&lt;/strong&gt;其实对于我来说，不喜欢反而更能准确。和打仗一样，有时候不一定是有共同的目标而携手作战，而是因为有着共同的敌人。&lt;/p&gt;

&lt;h3 id=&#34;我就是我-是颜色不一样的烟火:1c3125473ed37800649884e0f74ea659&#34;&gt;我就是我，是颜色不一样的烟火&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;谷歌已经实现了，在大规模定制。我们很多创业，包括我正在工作的内容一样，也是在数字领域内，为用户做着个性化定制。在数字领域里，它变得没有那么困难和遥远，但在现实生活里，个性化定制仍然是奢侈品，仍然难以普通化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网络时代，尤其是我这种职业就是码农的人来说。所谓的个性化，已经不仅仅是趋势，真的就是这本书的题目那样，个性化是一种必然，这种必然在网络上，在数字上，正在发生。但现实生活里，工业化仍是这个社会的主题，个性与定制对于每个人来说的确很遥远。&lt;/p&gt;

&lt;p&gt;我喜欢张国荣的那首《我》，尤其是这句歌词——&lt;strong&gt;我就是我，是颜色不一样的烟火&lt;/strong&gt;。寥寥几字，却让我深深的着迷其中。我们人，为了生存而群居变得一样，但却又一直挣扎着，想变得不一样，真是奇怪。网络开启了这个门，越来越多的公司和企业在网络上为他们的用户提供各种各样的个性化定制，就像在亚马逊，我们每个人看到的首页的内容都是不一样的。但越是如此，在现实生活里，我们就不得不面对，普通化和工业化。个性似乎只能存在数字世界里&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是！但是！但是！我们真的需要吗？需要在现实里同样那么个性化吗？数字领域里的个性化真的不足够满足我们的个性化吗？&lt;/strong&gt;
我似乎从来不用虚拟世界这个词，大多数文字里我都用的，数字领域，数字世界，网络世界这样的词汇。大概本身是因为从事互联网开发，所以世界观来说，这个世界并不虚拟，反而真实的可怕。更何况，我感觉网络对我的改变更加的快速和迅猛，越发离不开手机和网络。我深深的感到，在数字里的时间超过我再现实生活里的时间，既然如此，数字和现实，哪个算真哪个又叫虚拟呢？&lt;/p&gt;

&lt;p&gt;也是如此，现实生活里的个性化虽然仍遥不可及，但在数字世界里的时间越长，反倒觉得现实里的那个性化不重要了。我似乎真的不太需要定制的拖鞋，定制的沙发，定制的台灯，因为我更需要定制的界面，定制的交互，与定制的功能。&lt;/p&gt;

&lt;p&gt;我们总在努力如何将现实中的东西复制到网络世界里，却忘了，在网络世界，我们需要吗？&lt;/p&gt;

&lt;h3 id=&#34;时间是个伪命题-但注意力是真命题:1c3125473ed37800649884e0f74ea659&#34;&gt;时间是个伪命题，但注意力是真命题&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;这就是后稀缺。我们只能与宏达世界的一小部分建立链接。所以，反过来，从宏达世界的方向来看，唯一稀缺的就是人类的注意力。
所以注意力留在哪里，金钱就就在那里。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同样，当我看到必然中举了这么一个例子，当我们因为投放简历或者投放广告等向对方发送邮件，那么收件人可以向发件人征收打开费用！邮件被打开阅读，费用就会被扣除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个逻辑非常的棒。向他人注意力支付报酬原则。&lt;/strong&gt;
时间是个伪命题，它的确稀有，甚至比金钱稀有，世界上有很多东西难以复制，但想破脑袋也总有那么一点点复制的可能，唯独时间没有。绝对的不可复制，让时间成了珍品，也是我们经常说的那样，一寸光阴一寸金，寸金难买寸光阴。但可怜的是时间不仅仅只是不可复制，还不可存储。一天只有24小时，不会多出一秒，却也不会少一秒。无论你有多少事情要做，只有24小时，但巧的是你什么事情都不去做，也有24小时。不可复制，也不可存储。你如果不用掉这个时间，那么不好意思，你只能浪费掉这个时间。所以时间是个伪命题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但注意力不是！&lt;/strong&gt;时间是亘古的，就在那里。注意力不是，注意力停在哪里，哪里就是工作，哪里就是生活。
网络给了我们一个大大的空间，让我们与这个世界的链接变得不那么困难，不在那么遥不可及。我们不用跑到亚历山大图书馆去找珍贵的单本，也不用跑到耶鲁大学去听公开课，这些你都可以通过google得到。发现了吗？在我们这个时空的世界里，空间被‘压缩’了，那些本来在空间上占据‘稀有’这个标签的东西，渐渐变得普通甚至廉价。同样，空间上的链接变得越来越容易，信息也同样变得越来越容易，容易的东西就会泛滥，这个时候，无法被网络复制的东西便会珍惜起来。注意力，基于时间成本上的这个东西，慢慢的变得稀有。因此，网络时代，注意力成了资源，成了‘货币’。
&lt;strong&gt;注意力留在哪里，金钱就在那里。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是选择:1c3125473ed37800649884e0f74ea659&#34;&gt;什么是选择？&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;我们现在的选择权是越来越大。网购扩大的不仅仅是商圈，更是无限扩大了我们的选择权，那么，我们会选什么？那么，我们会怎么选？那些数据洪流，和我们生存或者说监视了我们好几年的数据，在帮我们选，事实上应该说，它们能预期到我们将会问什么。&lt;/p&gt;

&lt;p&gt;然而，我们并不知道自己想要什么。人就是这么奇怪，这么贱。相反，数据会告诉我们，我们想要什么，它是由我们自身行为所产生的建议和推荐。就像一面镜子。让我们看到自己想要什么的镜子。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;那么-什么是选择:1c3125473ed37800649884e0f74ea659&#34;&gt;那么，什么是选择？&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>幸福，兄弟</title>
      <link>https://zllbird.github.io/2016/05/28/%E5%B9%B8%E7%A6%8F%E5%85%84%E5%BC%9F/</link>
      <pubDate>Sat, 28 May 2016 16:24:26 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/05/28/%E5%B9%B8%E7%A6%8F%E5%85%84%E5%BC%9F/</guid>
      <description>

&lt;h2 id=&#34;幸福-兄弟:99c5c5d3b863827ac589b345707f26ee&#34;&gt;幸福，兄弟&lt;/h2&gt;

&lt;p&gt;感冒似乎又加重了，本来计划写的文字又拖了。算了，还是忍不住爬起来，开始写这篇文字。&lt;/p&gt;

&lt;p&gt;我有一个兄弟，代号狐狸，前天结婚了。
新婚快乐，狐狸，非常的遗憾，我没能到现场，真的非常遗憾，我好渴望去现场看看，那应该是一个句号，很完美的那种，代表一个故事的结束和另一个故事的开始。&lt;/p&gt;

&lt;p&gt;我的文字里总是会出现狐狸（真的有这么一只狐狸），他也算是个名言大师，总会在不经意之间，吐出象牙，对于一只狐狸来说，嘴里能吐出象牙已经是很难得事情了。我和他开玩笑说，以后你说的多了，可以出本书，书名我都给你想好了，人家白岩松出本书叫白说，你也一样，出本书叫胡说（狐说），胡说八道的那个胡说。然后，他就会赶紧接上说，好呀好呀。&lt;/p&gt;

&lt;p&gt;在我这一群‘狐朋狗友’中，狐狸是&lt;strong&gt;第一个&lt;/strong&gt;结婚的，先驱总是会比剩下的人更面对更多困难，但也总比剩下的人收获更多。我们都问，狐狸，结婚到底是什么感觉？狐狸想了想说，累，很累&amp;hellip;妈的，累死老夫了。所以，我们都知道了，结婚真的很累人。但狐狸说这话的时候，一直掩盖不住笑意。所以，我们不知道，结婚到底有多满足自豪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;又一次，感到无比的遗憾，未能去你的婚礼，未能亲眼看到你们走过红毯，未能亲口跟你说上那句新婚快乐，未能&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这似乎是一个节点。从狐狸开始，终于也轮到我们这群人，慢慢走入婚姻，慢慢组建家庭，慢慢的开始柴米油盐，从那个小小的我变成那个大大的我。我们一直承载着父母的关怀，终于，要和另一个人一起，组建一个新的家。生活似乎变得不太一样，一下子要去想很多东西，一下子又要规划很多东西。&lt;/p&gt;

&lt;p&gt;狐狸说过，这群牲口们似乎都说过，喜欢过得过且过的生活，喜欢无拘无束的日子，不要去规划，也不愿去规划。但现在，只能自己打自己的脸了。因为生活不再是一个人的事儿了，是两个人，以后可能还会是三个人或四个人的事儿。我们不在无所畏惧，因为我们不在孤军奋战，人有了牵挂，就会变得不一样。
写着写着，就莫名的羡慕了。&lt;/p&gt;

&lt;p&gt;狐狸的故事，我看着看着，看了快十年，结果就这么错过了大结局。狐狸的爱情已经跑了十年，浪漫吗？当然浪漫，问人生能有几个十年，三十岁之前你能有几个十年？而且，最终走过红毯，许下今生的诺言，从此海枯石烂，粗茶淡饭，不离不弃的那个人，已经陪了你十年，&lt;strong&gt;卧槽，这么算算，真的幸福到爆！&lt;/strong&gt;。我从18岁，看着这个故事走到现在，结果最后的大剧照合影里没有我，&lt;strong&gt;妈蛋啊，真不甘心！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;末了。我其实也是个傻乎乎的人，我也准备了一份小小的稿子，打算到现场的时候，说给狐狸听。&lt;strong&gt;妈蛋的，稿子也没说，真不甘心啊：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;想起七八年前，狐狸还喜欢染一头的红发，大晚上不好好上自习一群牲口出去喝酒，我真的记不起到底有几头牲口在场，我们在一起聊，梦想！对，一群不到十八岁的孩子不好好学习，跑出去喝酒还大谈梦想，大家一人一嘴不着实际的说着，轮到狐狸的时候，在那最最年轻无畏的时候，在那爱情超过全部的时候，狐狸说：&lt;strong&gt;她就是我的梦想！&lt;/strong&gt;或许狐狸不知道，他当时说出了我听过的最美的情话。
而现在，&lt;strong&gt;你的梦想实现了，祝贺你，新婚快乐，兄弟！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>闭包，编程思考</title>
      <link>https://zllbird.github.io/2016/01/20/%E9%97%AD%E5%8C%85%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 20 Jan 2016 13:30:51 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/01/20/%E9%97%AD%E5%8C%85%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</guid>
      <description>

&lt;h2 id=&#34;闭包-编程思考:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;闭包，编程思考&lt;/h2&gt;

&lt;p&gt;缘由：经常会文章里看到闭包，对闭包有种感念，但有时候会绕进去。正好加上，android端的构建使用了gradle，gradle脚本基本上都是由闭包构成和撰写的，便研究了一番。更加巧合的是，参与iOS问题讨论的时候，发现了Block这种编写方式，越发觉得这些都是速途同归的玩意。&lt;/p&gt;

&lt;h3 id=&#34;摘要:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;摘要：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;闭包定义&lt;/li&gt;
&lt;li&gt;解读闭包&lt;/li&gt;
&lt;li&gt;闭包的意义&lt;/li&gt;
&lt;li&gt;不同语言对于闭包的另类实现&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;闭包定义:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;闭包定义&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Closure_(computer_programming&#34;&gt;Wiki上闭包的解读（很精彩）&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;闭包的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;closures&lt;/strong&gt; (also &lt;strong&gt;lexical closures&lt;/strong&gt; or &lt;strong&gt;function closures&lt;/strong&gt;) are a technique for implementing &lt;a href=&#34;https://en.wikipedia.org/wiki/Lexically_scoped&#34;&gt;lexically scoped&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Name_binding&#34;&gt;name binding&lt;/a&gt; in languages with &lt;a href=&#34;https://en.wikipedia.org/wiki/First-class_function&#34;&gt;first-class functions&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以给个中文版本的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解读闭包:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;解读闭包&lt;/h3&gt;

&lt;p&gt;好吧好吧，无论是英文还是中文，读起来感觉都特别的绕口，理解起来就更绕口了。&lt;/p&gt;

&lt;p&gt;还是直接暴力点吧，直接来代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;function startAt(x)
   function incrementBy(y)
       return x + y
   return incrementBy

variable closure1 = startAt(1)
variable closure2 = startAt(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;这是基于python的闭包的写法。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（在我的接触中，python语言是较为简单的，入门比较低，即便没有入门，看代码也不是困难，所以拿python举例，当然，建议大家都学学这个语言，一般一个星期写简单的程序就没问题了）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（python中，缩进代表 {} 符号）&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&#34;解读:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;解读：&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;startAt&lt;/code&gt;是一个函数，或者叫方法。它的返回值也是一个函数，或者叫，它返回一个函数类型的值。&lt;/p&gt;

&lt;p&gt;那么有意思的来了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;closure1(3) = 4
closure2(3) = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，&lt;code&gt;startAt&lt;/code&gt;到底是什么？&lt;/p&gt;

&lt;p&gt;解释它之前，先解释一下变量closure1 和变量 closure2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;closure1 = 1 + 参数
closure2 = 5 + 参数
//所以 closure2(3) = 5 + 3 = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发觉，&lt;code&gt;startAt&lt;/code&gt;是定义了一种加法。但属于它的变量&lt;code&gt;x&lt;/code&gt;却离开了&lt;code&gt;startAt&lt;/code&gt;一直和&lt;code&gt;closure1&lt;/code&gt;和&lt;code&gt;closure2&lt;/code&gt;存在，赶紧回去看一下刚才最初的定义。&lt;/p&gt;

&lt;p&gt;下面是我最喜欢的一段对于闭包的解读：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Closures are typically implemented with a special &lt;a href=&#34;https://en.wikipedia.org/wiki/Data_structure&#34;&gt;data structure&lt;/a&gt; that contains a &lt;a href=&#34;https://en.wikipedia.org/wiki/Function_pointer&#34;&gt;pointer to the function code&lt;/a&gt;, plus a representation of the function&amp;rsquo;s lexical environment (i.e., the set of available variables) at the time when the closure was created. The referencing environment &lt;a href=&#34;https://en.wikipedia.org/wiki/Name_binding&#34;&gt;binds&lt;/a&gt; the non-local names to the corresponding variables in the lexical environment at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is *entered* at a later time, possibly with a different lexical environment, the function is executed with its non-local variables referring to the ones captured by the closure, not the current environment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;闭包的意义:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;闭包的意义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;因为闭包只有在被调用时才执行操作，即“&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&#34;&gt;惰性求值&lt;/a&gt;”，所以它可以被用来定义控制结构。例如：在&lt;a href=&#34;https://zh.wikipedia.org/wiki/Smalltalk&#34;&gt;Smalltalk&lt;/a&gt;语言中，所有的控制结构，包括分歧条件(if/then/else)和循环(while和for)，都是通过闭包实现的。用户也可以使用闭包定义自己的控制结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;感受一下，一会儿看到各个语言的实现，就能有那种醍醐灌顶的感觉了。&lt;/p&gt;

&lt;h3 id=&#34;不同语言对于闭包的另类实现:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;不同语言对于闭包的另类实现&lt;/h3&gt;

&lt;p&gt;解读完闭包了，聊一下，这个玩意最大的问题是什么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt; &amp;ndash;&amp;gt; 自由变量的作用域，导致自由变量的混乱管理。&lt;/p&gt;

&lt;p&gt;我将先以&lt;code&gt;javascript&lt;/code&gt;为例，介绍最大的问题。&lt;/p&gt;

&lt;p&gt;然后，我再会分别介绍一下&lt;code&gt;java&lt;/code&gt;以及&lt;code&gt;Object-C&lt;/code&gt;为例子，解释一下其他语言是如何另类实现闭包，并怎么处理作用域的问题。&lt;/p&gt;

&lt;h4 id=&#34;javascript-的闭包:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;&lt;code&gt;javascript&lt;/code&gt;的闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// ECMAScript , javascript
var f, g;
function foo() {
  var x; // 
  f = function() { x = x + 1 ; return x; }; //
  g = function() { x = x +5 ; return x; };	//
  x = 1;
  alert(&#39;inside foo, call to f(): &#39; + f()); // 2
}
foo();
alert(&#39;call to g(): &#39; + g());  // 7
alert(&#39;call to f(): &#39; + f());  // 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到结果为。&lt;/p&gt;

&lt;p&gt;如果我将输出顺序换一下呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;alert(&#39;call to f(): &#39; + f()); // 3
alert(&#39;call to g(): &#39; + g()); // 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给你们两分钟时间，再想一下。&lt;/p&gt;

&lt;p&gt;可以看到。在&lt;code&gt;foo&lt;/code&gt;中声明的变量&lt;code&gt;x&lt;/code&gt;，由于闭包的存在，导致&lt;code&gt;x&lt;/code&gt;的作用域一直扩展到程序的底部，在&lt;code&gt;foo&lt;/code&gt;函数结束后还一直坚挺的活着。（这是我们刚才已经知道了的。）&lt;/p&gt;

&lt;p&gt;不仅活着，还可以被更改，然后再使用！&lt;/p&gt;

&lt;p&gt;那么问题到底是什么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;难以管理。&lt;/li&gt;
&lt;li&gt;持有。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;java-以及-object-c-对闭包的-实现:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;&lt;code&gt;JAVA&lt;/code&gt; 以及&lt;code&gt;Object-C&lt;/code&gt;对闭包的‘实现’&lt;/h3&gt;

&lt;p&gt;直接说，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java&lt;/code&gt;中是 匿名内部类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object-c&lt;/code&gt;中是 Block运用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以基于这点来讲，&lt;code&gt;java&lt;/code&gt;更加面向对象一点，真的是很努力做到一切都是对象了。&lt;/p&gt;

&lt;p&gt;先看一下&lt;code&gt;java&lt;/code&gt;代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void foo(){
   final int x = 1 ; //

  //f(lambda (x) -&amp;gt; person.setAge(x));

  f(new OnChangListner(){
  		void onChang(){
  			person.setAge(x);
		}
	});

  // 当然方法f必须事先定义好
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再看一下&lt;code&gt;object-c&lt;/code&gt;的BLOCK:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)foo {
    NSInteger x = 1;

    void (^f) (NSInteger *) = ^(NSInteger *x)
    {
      x = 4; // 异常  
      NSLog(@&amp;quot;foodname:%@&amp;quot;, x);
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思吧。&lt;/p&gt;

&lt;p&gt;这样既能完成传值，又成功的避开了作用域的问题。&lt;/p&gt;

&lt;p&gt;当然，本质上来讲，这已经不是闭包了。&lt;code&gt;java&lt;/code&gt;里&lt;code&gt;onChang&lt;/code&gt;中的&lt;code&gt;x&lt;/code&gt;和定义的&lt;code&gt;x&lt;/code&gt;其实已经不是一个内存了，而我们需要的不是一个内存，而是一个相同的值。&lt;/p&gt;

&lt;p&gt;这也是我为什么将实现两个字打上了引号。&lt;/p&gt;

&lt;p&gt;贴一下对于其他语言对于‘类’闭包的结构或者设计：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Callbacks (C)
Local classes and Lambda functions (Java)
Blocks (C, C++, Objective-C 2.0)
Delegates (C#, D)
Function objects (C++)
Inline agents (Eiffel)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思考:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;思考&lt;/h3&gt;

&lt;p&gt;说两句感悟，大家随便感受一下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所谓的设计模式也好，这种和闭包语法类似的东西也好。原因大多不是语言设计者要装x而搞出来的，大多数都是因为，内建不够。一个语言设计模式越多，或者说，为了一种实现折腾的过程越多，其实越代表语言的局限性越大。&lt;/li&gt;
&lt;li&gt;因为同时兼顾Android和iOS开发，所以可以明显感觉到，&lt;code&gt;object-c&lt;/code&gt;的限制太多，或者说内建较差。所以才有swift，我也简单学习了swift的基础语法，可以说内建相当的不错。当然，java也不怎么样，新兴的很多语言对于设计要比java优秀很多（比如，方法可以多个返回）。&lt;/li&gt;
&lt;li&gt;学习其他语言。比我们想象的要简单的多。（抽空单独出文章）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;mdash;-—-&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>感想 我该如何成长</title>
      <link>https://zllbird.github.io/2015/11/25/%E6%84%9F%E6%83%B3-%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF/</link>
      <pubDate>Wed, 25 Nov 2015 09:25:11 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2015/11/25/%E6%84%9F%E6%83%B3-%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF/</guid>
      <description>

&lt;h1 id=&#34;感想-我该如何成长:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;感想-我该如何成长&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;我始终相信，优秀归根到底是自己的事儿，所以成长，归根到底，也是要靠自己。 ——飞鸟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几天前和一个朋友聊起学习，又被一阵吐槽。说是被老板压榨，没有时间学习，等等巴拉巴拉&amp;hellip;又突然想起一个同事，总是感慨总是被公司的业务羁绊，向业务妥协。便有了这篇感慨。&lt;/p&gt;

&lt;p&gt;然后，我很认真的问自己，我该如何成长？&lt;/p&gt;

&lt;p&gt;想明白这个问题之前，应该先想明白另一个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我到底想成为一个什么样子的人？&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;相信自己而不是相信依靠:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;相信自己而不是相信依靠&lt;/h3&gt;

&lt;p&gt;有个同事说起这么一番话，我直接抄过来了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在思路上, 技术大牛确实给了很多启发, 甚至可以说不是技术细节的启发, 对我来说都是颠覆性的想法, 这些思路靠自己研究, 并且又在业务迭代的压力下几乎是不可能的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我其实很承认这句话的。尤其是和一些优秀和专研的人聊天，往往听完后，第一感觉就是听君一席话，胜读十年书啊。（当然，不仅仅局限技术大牛。）&lt;/p&gt;

&lt;p&gt;可惜的是，倾听我准备好了，求教我也准备好了，该准备的都准备好了。正所谓万事俱备，只缺一个技术大牛。&lt;/p&gt;

&lt;p&gt;好吧，有能指点的技术大牛是幸运的。但如果没有，其实也没那么糟糕。因为这个时代不仅不缺技术大牛，而且大牛们都还很喜欢分享。想想中国古代的老师傅们，总要留一手，不让本事全被徒弟学去了，而如今的大牛们，恨不得把自己的会的全都拿出来让你看看。&lt;strong&gt;（我一直庆幸自己能在这样一个时代里去拼搏&lt;/strong&gt;。）&lt;/p&gt;

&lt;p&gt;所以金山银山颜如玉神马的都有，只不过那些让你醍醐灌顶的指点都散落在网络上各处，只不过这次是需要你自己去找。&lt;/p&gt;

&lt;p&gt;我想说的是，不要去依赖，如果非要依赖，也只能依赖自己，相信自己。&lt;/p&gt;

&lt;h3 id=&#34;有捷径请走捷径-如果没有-请更加努力:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;有捷径请走捷径，如果没有，请更加努力&lt;/h3&gt;

&lt;p&gt;不得不承认，有人带着学习或者成长，会比自己摸石过河要快很多，少犯错，少走路。我是一个捷径主义者，所以，那些所谓打基础啊，吃亏是福啊，这是一种锻炼啊之类的话，我都认为是扯淡。&lt;/p&gt;

&lt;p&gt;聊点题外话，中学化学有一种推断ABCDEF是什么物质的题，大概是下面这个样子。每次做这种题，我都直接把出现最多的字母当成O，氧气。或者遇到无色透明液体，我直接就写成水。然后再一推断，一两分钟就能解决这个题。这个方法我从初三一路用到高考都不带失手的。捷径这么好用，为啥不用呢。&lt;/p&gt;

&lt;p&gt;聊完题外。回来说说，如果真没有人带，需要自己摸黑，走一步算一步的时候，我只能说。请更加努力，请更加劳苦，虽没有捷径可走，但至少还可以多付出。&lt;/p&gt;

&lt;h3 id=&#34;完美这个伪命题:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;完美这个伪命题&lt;/h3&gt;

&lt;p&gt;从小在做生意的人堆里长大，所以听到被人说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;只是单纯而简单的钻研技术, 把每个模块每个函数写到自己觉得完美.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样的话。我就很不舒服。在我心里大概有这么一个评级，不足，足够，优秀，完美。而我呢，是一个追求优秀，但忌惮完美的人。我潜意识里，完美等于巨大的物力，人力，财力，以及时间，一句话——高额成本！一旦遇到高额成本，我就会吓得慌。&lt;/p&gt;

&lt;p&gt;也怪我太贪心，不够专注。或者猎奇心太重，总想着尝试新的技术，新的东西，新的领域。所以，在我看来去追求完美，真的太浪费了。不是有句名言这么说的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不追求完美，何尝不是一种放下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;刚开始学习JAVA的时候，对各种设计模式学习，那叫一个如此如醉，奉若神技。但随着时间慢慢过去，现在反倒觉得那么多设计模式，何尝不是一种累赘。一方面，写出的代码怎么看都觉得有那么点相似，另一方面，有一种变相的冗长。再后来，接触了javascript，python等后，（现在学习Go中），越发着发觉，所谓的设计模式，本质上是Java语言本身的内建不够啊。&lt;/p&gt;

&lt;p&gt;想明白这点后，设计模式就再也不神秘了。好像又写的有点跑题了，回到完美这个梗。Java本身是有缺陷的，所以已阻止了完美的步伐，或者这样说：用Java写了一个&lt;strong&gt;完美的&lt;/strong&gt;方法，模块。但这种完美却很脆弱。脆弱到，一不小心，被时代淘汰了。&lt;/p&gt;

&lt;p&gt;时代太快了，快的让我不敢只专注于一项技巧与一种语言。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>