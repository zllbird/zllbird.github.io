<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Coder-bird</title>
    <link>https://zllbird.github.io/post/</link>
    <description>Recent content in Posts on Coder-bird</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2015 Copyright Text</copyright>
    <lastBuildDate>Thu, 12 May 2016 10:13:20 +0800</lastBuildDate>
    <atom:link href="https://zllbird.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>给测试一个可以‘测试’的环境</title>
      <link>https://zllbird.github.io/2016/05/12/%E7%BB%99%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 12 May 2016 10:13:20 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/05/12/%E7%BB%99%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E7%8E%AF%E5%A2%83/</guid>
      <description>

&lt;h2 id=&#34;给测试一个可以-测试-的环境:58aa416285a8b6da672fedefb2540a53&#34;&gt;给测试一个可以‘测试’的环境&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;也算是一点心得。随便聊几句，感受下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;现在的软件开发，至少有两个环境，一个是测试环境，用来开发、更改、调整代码，只提供给内部使用的环境。另一个是正式环境（线上环境），提供给外部使用的环境。当然，一般还有一个灰度测试环境，用于从测试环境到正式环境的缓冲带，给内部使用真实的环境。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;废话说完。
说实情，也是我准备更改的一件事情。&lt;strong&gt;不能给测试提供一个，可以有效用来进行测试的环境。&lt;/strong&gt;
测试本身，是存在大量重复和冗余工作，这点无法消除。但的确也存在，不必要的重复和冗余，导致测试的工作即便和饱和，但产品的质量却仍然得不到一个很好的保证。&lt;em&gt;（加上，我们的测试比较嫩，更容易被开发忽悠）。&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提供给测试的环境不完整！&lt;/strong&gt;对于测试来说，这是一个相当大的拖累，对于项目来说，这是一个非常错误的信息，会让项目的所以协作者都误以为达到了某种节点或者里程碑，但事实上，这本就应该是未达到测试标准。偷换了概念，用不完整掩盖未达标，从而将工作转移到了修复和维护上，自然加重了测试的工作量。可怜的是，包括工程师在内，都不是有意为之，因为工程师在这个环节中，也是受害者——提测后的压力本就大于开发期的压力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供给测试可以调控状况的能力！&lt;/strong&gt;在阶段性测试中，经常会遇到，由于这样那样的原因，导致测试频繁的（过度频繁的）要求开发提供响应的状况，双方都在这过程中产生大量的相互等待和相互影响，这是一种高额成本的损耗，而且相当没有意义。（简单举例说明，测试经常需要开发更改标志性时间戳，更改对应账号的参数，更改客户端请求不同服务器等）事实上，这不仅仅是损耗，还有可能在相互的更改中，忽略其他相关的问题。这点颇有心得，开发总会忽略一些调控状态的输出，但如果发生一个测试经常会要求更改的状况的话，开发本就应该提供相应的输出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;给测试足够的否决权！&lt;/strong&gt;说完两个硬环境，说一个软环境。测试本身有否决开发的权利，当然这点我们团队做的有些缺陷，仍然在补全中，但毋庸置疑。而我这次想说的却是，测试也有相当一部分否决&lt;strong&gt;产品&lt;/strong&gt;的权利。这点我想了很久，对于小团队来说，测试是项目输出的第一道守护，很大程度上，测试对于项目输出的具体形态有着相当大影响，如此，否决&lt;strong&gt;产品&lt;/strong&gt;很大程度上能制约乱改乱加现象，同时也能维护住成本。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，尽早构建CI，绝对是测试的福音。自动构建系统，至少满足两点。
1. &lt;strong&gt;不依赖开发，只需要开发做不定时的维护就可以。&lt;/strong&gt;
2. &lt;strong&gt;可以提供多种环境的构建。&lt;/strong&gt;
3. &lt;strong&gt;可以自动发布。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>对于项目维护的思考</title>
      <link>https://zllbird.github.io/2016/05/12/%E5%AF%B9%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Thu, 12 May 2016 10:11:31 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/05/12/%E5%AF%B9%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>

&lt;h2 id=&#34;对于项目维护的思考:864c5fb8efa8298af296d9c83121ecb7&#34;&gt;对于项目维护的思考&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;漫谈。
程序写多了，对于一个项目的维护久了，产生了一些特别不一样的想法，写下来，与人念叨念叨。&lt;/p&gt;

&lt;h3 id=&#34;实际开发:864c5fb8efa8298af296d9c83121ecb7&#34;&gt;实际开发&lt;/h3&gt;

&lt;p&gt;说维护，自然要从&lt;strong&gt;实际&lt;/strong&gt;开发说起。
特别的聊一下加粗的这两个字，&lt;strong&gt;实际&lt;/strong&gt;。
实际开发中，总是会有状况发生的，这是定律，所以，对于实际开发来说，我第一个想法就是短，准确说，别做太多事让整个开发周期拉长。短是方便控制，同时也便与紧急处理。实际落实过程中，总是会出现这样或者那样的妥协，我们尝试了很多办法去减少状况的发生，刚开始还不错，但随着这样或者那样制度的复杂度加深，效果却越来越小，甚至反弹。只能说，通过外力去减少异常状况的发生，有用，但没有那么有用。
所以，把目光转回来。
&lt;strong&gt;如何紧急处理紧急问题，成了实际开发中的最大的问题。&lt;/strong&gt;就如我刚才所说的那样，这其中总会掺杂着这样或者那样的妥协，这篇是技术文，暂时抛开产品的专业性，就技术而言。如何紧急处理问题？
1. 减少复杂度。（&lt;strong&gt;这是最最重要的一条&lt;/strong&gt;）在绝大多数情况下，我们处理的问题本身的复杂度，不会超越技术本身的承受力。（相信我，超过的问题，一般都会有更牛的人在前面帮你开拓了）所以，大多数看起来复杂到不可控的问题，都是由于我们的认知不够，有可能是认知缺失，也有可能是疏忽，所以看起来很复杂。但实际却经不起推敲。所以，减少复杂度，我给的建议很简单，找到相关的人，坐下来，重新梳理之后，做减法，减掉不必要的复杂选项后，再做修复。减少复杂，不代表肯定是减少功能，这几年和产品的博弈过程中，每次找产品，产品都觉得是我在减功能，囧。&lt;strong&gt;重申一遍，梳理逻辑才是重中之重。&lt;/strong&gt;
2. 解耦。紧急问题的处理，总会有那么一种‘写死’的方案，或者说，总有那么一种成本低但耦合度高的方案可以勉强解决问题。千万不要这么做，这就是‘泥石坑’（人月神话），除非你不考虑下个版本，否则，这只能让你下个月的工作大大增加。因为，你不得不用一个很高昂的成本来弥补你这个时候偷的懒。
3. 尽早寻求帮助。紧急的问题加上时间的压榨，很容易让身处‘局里’的人盲目或者过激。不理智是留下遗留问题的根源，这里我自身也犯下了好几次错误。不得不说，坦诚承认，然后及时向他人寻求帮助是最好的对策，保证项目是首要，至于那一点点羞耻心真的不重要。因为纸包不住火，维护的时候终究还是要面对的。&lt;/p&gt;

&lt;p&gt;其实，说了这么多，感觉都跑题了。其实，我想说，项目维护时流的汗水，都是开发时，你处理紧急问题时脑子进的水。
&lt;strong&gt;不顾以后的维护，只图解决眼下的问题，终究是要偿还的。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;实际维护:864c5fb8efa8298af296d9c83121ecb7&#34;&gt;实际维护&lt;/h3&gt;

&lt;p&gt;维护或者优化。最重要的是：&lt;strong&gt;千万改完一个bug，又改出来一个。&lt;/strong&gt;
然后，这个事情基本上是我所见到的实际维护过程中最高频率出现的事情之一。而其中大多数原因，就是缺少思考的修改了原来的代码。这么讲的话，难道维护或者优化的时候修复一个bug，要来来回回的思考和判断逻辑才能改原来的代码吗？全部这么做的话，成本岂不是太过于高昂了。
&lt;strong&gt;不好意思，的确是这样的。维护时期修复一个问题，要比开发时期困难很多很多。&lt;/strong&gt;在一个勉强称得上稳定的系统上（默认上线的版本是较为稳定的版本），是它变得更加稳定和可靠是一件很难得事情。因为任何的修改的前提是，不能破坏原来的稳定。一句，不能破坏原来的稳定，就是最大的成本。
同时，维护还要尽量保证后来的维护或者优化能顺利进行，所以刚才的123点同时也是要注意。
也再说几点我的心得。
1. 时间是最大的成本。相信没有真正的维护时期，都是或多或少掺杂着新的开发，所以所谓的维护时间，并没有想象中的那么长。同时，人们总有种倾向，会认为新开发的优先级会高于旧维护的，毕竟，一个已经有了只是存在问题，另一个还没有。这种倾向会传染，让我们不自主的给维护更少的时间。
2. 拒绝拖延。程序开发里有一个不成名的定律，但凡说，以后改的问题，最终也没有改。说下一次就修复的事情，再也没有出现过下一次。这是个很伤心的事情，人始终不断的尝试或者做新的事情，的确能获得很多，同样，在修复和更改中，也能获得同样多，但却很少有人这么做。鸡汤说完，说实情。如果旧的问题始终不处理，会导致新的功能的不完整，连带出来很多新的问题。很少有功能或者说需求是完全和旧版本脱离的，自然使用也要不断使用旧版本中已经完成的功能，所以，拖延只能导致不断前进的步伐陷入‘坑’，举步维艰。&lt;/p&gt;

&lt;p&gt;随便写点，先写这么多吧。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>CI</title>
      <link>https://zllbird.github.io/2016/05/12/ci/</link>
      <pubDate>Thu, 12 May 2016 10:09:32 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/05/12/ci/</guid>
      <description>

&lt;h2 id=&#34;android-ios-双平台搭建ci心得-jenkins-gitlab-gradle-android-xcode-ios-fir-im-分发:fdf16477251a83f9aa87d6f1a4ff3aeb&#34;&gt;Android,iOS 双平台搭建CI心得（Jenkins + GitLab + Gradle(android)/Xcode(iOS) + fir.im(分发) ）&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;概述:fdf16477251a83f9aa87d6f1a4ff3aeb&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;由于上一篇写到想尽早搭建移动端的CI，这两天便一直折腾。总算有点结果，至于细致下来，还需要一些时间去专门调整后，再移交个QA。
&lt;em&gt;去年写过一篇，关于使用jenkins如何为安卓搭建自动生成分发的平台，左边目录点击就能找到。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;自动构建平台：&lt;code&gt;jenkins&lt;/code&gt;
版本控制：&lt;code&gt;git&lt;/code&gt;
编译工具：&lt;code&gt;Gradle(android)&lt;/code&gt;/&lt;code&gt;Xcode(iOS)&lt;/code&gt;
分发工具：&lt;code&gt;fir.im - fir-cl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;选择&lt;code&gt;jenkins&lt;/code&gt;主要考虑到它比较稳定，另外一点是可以兼顾两个平台，别的平台大多数都是偏向&lt;code&gt;android&lt;/code&gt;或者&lt;code&gt;iOS&lt;/code&gt;中一个。别的不用说，分发工具选择&lt;code&gt;fir&lt;/code&gt;,在实践中发觉fir平台很稳定，非常适合做分发平台，而且重要的是，&lt;strong&gt;免费&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;android:fdf16477251a83f9aa87d6f1a4ff3aeb&#34;&gt;Android&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zllbird.github.io/2015/11/30/android%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/&#34;&gt;Android自动构建&lt;/a&gt;
这篇是我以前写的，是完全可行的。这里做一点改造。
为满足，不同构建生成不同环境的APK包，而减少QA与开发之间沟通，并同时满足后台需要特定环境调试。所以构建平台要能提供相应的项目，释放开发的压力。
具体改造：
1. 为&lt;code&gt;Gradle&lt;/code&gt;配置全局变量，然后方便管理启用环境。因为我是使用Gradle进行配置，所以也同样使用Gradle属性赋值直接进行环境的更改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 在Gradle文件中，比如在我的项目中是 config.gradle

task serverName {
	println &amp;quot;SEVER IS ${SEVER_CONFIG_CI}&amp;quot;
}

# 配置 SEVER_CONFIG_CI 可以通过Gradle自定义属性，也可以通过JVM配置等，这里使用比较偷懒的方法，直接定义gradle中的属性配置,但要在前面添加ORG_GRADLE_PROJECT_作为前缀
export ORG_GRADLE_PROJECT_SEVER_CONFIG_CI = 2

#这个时候就可以直接在命令行里运行 gradle serverName ，就能看到 结果为SEVER IS 2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完后，只需要在编译前，运行一次这个命令，就能提供相应的服务器环境了。
&lt;img src=&#34;https://zllbird.github.io/images/auto-ci/3.png&#34; alt=&#34;&#34; /&gt;
1. 将Gradle配置部署到jenkins上，一个项目对应一个环境，便于管理。具体步奏，在项目的配置中的&amp;gt;构建&amp;gt;增加构建步奏&amp;gt;Execute shell ,输入刚才提到的配置。
2. fir分发，用命令工具替换插件。原先用的插件支持并不友好（对我来说，命令行比较友好），所以这次fir提供了fir-cl工具后，便毅然决然的替换了原来的插件。步骤和2一样，只不过命令变成了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fir publish ${WORKSPACE}/app/build/outputs/apk/app-baidu-debug.apk -T {firToken}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，我是直接在构建中使用了，也可以选择构建后。如果选择构建后运操作&amp;gt;增加构建后操作步奏&amp;gt;Excute a set of scripts&amp;gt;Build steps （或者Add a shell 将写好的脚本上传）
&lt;img src=&#34;https://zllbird.github.io/images/auto-ci/2.png&#34; alt=&#34;&#34; /&gt;
最后立即构建，享受吧~~~&lt;/p&gt;

&lt;h3 id=&#34;ios:fdf16477251a83f9aa87d6f1a4ff3aeb&#34;&gt;iOS&lt;/h3&gt;

&lt;p&gt;iOS 由于编译软件的限制，所以只能有苹果系统，包含Xcode的机器才能集成这套CI。
对于jenkins的安装这里不重复了，想了解的仍然是点击左边目录，Android自动构建里有。
由于我的项目中有Cocopods，所以具体配置中有些坑要注意。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Git拉去源码时可能会出现。十分钟就断开，导致项目拉去始终失败的可能。这里需要在项目配置中源码管理&amp;gt;Additional Behaviours&amp;gt;Advanced clone behaviours&amp;gt;Timeout for clone and fetch operations 中填入一个较大的值，防止timeout。
&lt;img src=&#34;https://zllbird.github.io/images/auto-ci/4.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;构建中，选择Xcode。具体配置实例如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;Target: JenkinsCI
Clean before build? YES
Generate Archive? YES
Pack application and build .ipa? YES
.ipa filename pattern: ${VERSION}
Output directory: ${workspace}/Builds/${BUILD_NUMBER}/${BUILD_ID}
Unlock Keychain? YES
Keychain path: ${HOME}/Library/Keychains/login.keychain
Keychain password: your administrator user password
Xcode Schema File: JenkinsCI
Xcode Workspace File: ${WORKSPACE}/JenkinsCI
Xcode Project Directory: ${WORKSPACE}
Xcode Project File: ${WORKSPACE}/JenkinsCI
Build output directory: ${WORKSPACE}/Build
Provide version number and run avgtool? YES
Technical version: ${BUILD_ID}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别要注意xcode workspace file 。由于pod使用时是通过workspace而不是project，所以不配置这个，构建始终不会成功。
1. fir分发。与android一样，这里我用了上面提到的第二种方法。
   &lt;img src=&#34;https://zllbird.github.io/images/auto-ci/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;未解决的问题:fdf16477251a83f9aa87d6f1a4ff3aeb&#34;&gt;未解决的问题&lt;/h3&gt;

&lt;p&gt;iOS如何构建脚本生成不同环境。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>iOS实践：一次失败的重构记实</title>
      <link>https://zllbird.github.io/2016/02/20/ios%E5%AE%9E%E8%B7%B5%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%87%8D%E6%9E%84%E8%AE%B0%E5%AE%9E/</link>
      <pubDate>Sat, 20 Feb 2016 16:33:44 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/02/20/ios%E5%AE%9E%E8%B7%B5%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%87%8D%E6%9E%84%E8%AE%B0%E5%AE%9E/</guid>
      <description>

&lt;h1 id=&#34;ios实践-一次失败的重构记实:08113914c16819b58c74ffda7bf76beb&#34;&gt;iOS实践：一次失败的重构记实&lt;/h1&gt;

&lt;p&gt;摘要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2月15日，原代码分析，研究重构点&#34;&gt;2月15日，原代码分析，研究重构点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2月16日，尝试进行自适应和图片加载重构&#34;&gt;2月16日，尝试进行自适应和图片加载重构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2月17日，重构进行中&#34;&gt;2月17日，重构进行中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2月18日，UI改造。&#34;&gt;2月18日，UI改造。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;2月19日，继续改造（图片逻辑处理方案以及一些感想）&#34;&gt;2月19日，继续改造（图片逻辑处理方案以及一些感想）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2月20日，图片加载模块重构&#34;&gt;2月20日，图片加载模块重构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2月15日-原代码分析-研究重构点:08113914c16819b58c74ffda7bf76beb&#34;&gt;2月15日，原代码分析，研究重构点&lt;/h3&gt;

&lt;p&gt;严重问题：&lt;/p&gt;

&lt;p&gt;多类型列表的数据源控制，不仅使用了多个数组，还使用了一个包含所有数组的大字典来做统一管理。导致以下问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;阅读分析困难。命名的随意性更加加重了对代码的分析阅读，很难找到 相互关联的 UI与 数据源。可以理解为，视图和控制器虽分离了，但关联他们的接口混乱，导致无从查起。&lt;/li&gt;
&lt;li&gt;数据管理困难。数据源相关的类皆为类属性（成员变量），大量方法函数对6个数据源列表进行操作，严重增加调试和查找困难。&lt;/li&gt;
&lt;li&gt;数据类型多和混乱。通过大字典管理各个列表，然后就完全没涉及各个类型的数据的关系，然后共享出了问题。更直接的是，没有继承，整个界面就是一堆数据往里面塞得感觉。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有意思的是，我本以为UI部分也会这样。但事实上，比我想象的要好非常多。有类型区分，有管理。UI的主要问题是没用自动布局，及其严重的增加了成本。尤其是对于动态的内容高度等计算。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;控件的布局困难。没有控件间的约束，导致控件之间的布局特别容易自己玩自己的去了。&lt;/li&gt;
&lt;li&gt;列表单元高度计算困难。过于动态的内容，导致控件过于复杂的计算。iOS系统中居然没有自适应这种东西，简直让我这个android工程师极度抓狂。&lt;/li&gt;
&lt;li&gt;单元模型设计的混乱。这个倒是可以理解，由于业务叠加的方向更改的任意性，产品变动的不可预测。直接导致单元模型的混乱，但也太混乱了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;解决思路参考:08113914c16819b58c74ffda7bf76beb&#34;&gt;解决思路参考：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;数据方面。&lt;/li&gt;
&lt;li&gt;- 数据源管理使用单一列表，不适用多列表加字典的方式

&lt;ul&gt;
&lt;li&gt;重新搭建继承关系。通过类型区分各个模型和单元&lt;/li&gt;
&lt;li&gt;数据的传递和共享可以通过回调处理，不需要硬塞。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UI方面。&lt;/li&gt;
&lt;li&gt;- UI整体使用自动布局和约束来替代现在的写法。

&lt;ul&gt;
&lt;li&gt;引入自动适应的label方案，减少对于label文字内容的适应问题。&lt;/li&gt;
&lt;li&gt;引入列表单元自动适应高度解决方案。真心想告别计算单元高度的日子。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;分析自适应解决方案:08113914c16819b58c74ffda7bf76beb&#34;&gt;分析自适应解决方案&lt;/h4&gt;

&lt;p&gt;打算引入SDAutoLayout这个三方自适应。初步研究后，发觉能较好的适应tableView的自适应高度和Label的自适应高度。而且这个项目现在有专门人员在github是维护，且项目更新频率很高。&lt;/p&gt;

&lt;h3 id=&#34;2月16日-尝试进行自适应和图片加载重构:08113914c16819b58c74ffda7bf76beb&#34;&gt;2月16日，尝试进行自适应和图片加载重构&lt;/h3&gt;

&lt;p&gt;数据方面的重新梳理和关系重构。&lt;/p&gt;

&lt;p&gt;原来的数据model类中居然包含单元格高度属性…也是够了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个典型的view和model未分离的情况。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新命名，并修改内部相关属性。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个世界上，总有一些傻逼是你躲不过去的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在是下午两点，简单说一些上午到现在做的一些东西。&lt;/p&gt;

&lt;p&gt;确认使用框架后，先对详情页的主贴和续帖进行重构。接下来进行了几项尝试。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在原CellView上进行修改。相继出现多过崩溃异常。放弃&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新撰写简单的CellView（只包含title 和一个 imageview）。进行调试，文本的自动适应和图片的自动适应相继成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新尝试1，但先进行cellview中，更改为autolayout，再进行自适应。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;相继出现各种不出现，同时由于方法相互关联太多，越更改越困难，调试也更加困难。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;重新尝试2，即从刚才较为简单的模型上添加控件，丰富界面，然后迁移点击事件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好吧。还是失败了。工作量太大，而且迁移的过程中存在大量的自定义view，导致需要查看大量自定义view，显得不是很现实。再想别的办法。&lt;/p&gt;

&lt;h3 id=&#34;2月17日-重构进行中:08113914c16819b58c74ffda7bf76beb&#34;&gt;2月17日，重构进行中&lt;/h3&gt;

&lt;p&gt;帖子详情页里，主贴，细小的功能非常之多。比我想象中的要困难很多。文本，文字很多需要转富文本，而且同时，还支持各种各样的点击。&lt;/p&gt;

&lt;p&gt;主要的图片问题，终于不得不面对了。帖子详情页的图片加载异常混乱，每次加载完一个图片，就会调用界面重绘，极大的加重了UI负担和界面不可控。也是引起帖子详情页加载会崩溃的原因。&lt;/p&gt;

&lt;p&gt;所以，暂时决定暂停UI，先行处理图片加载问题。&lt;/p&gt;

&lt;p&gt;比我想象的还要困难。略有小感：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;重构中困难的是取舍，原先代码是很糟（不糟谁重构啊），但却不能一下子全部抛弃，如果全部推翻重写的成本过于昂贵。
所以，预想中逐步重构，一点一点推翻。
但问题又来了，原先耦合性高且冗杂，加上复杂的业务逻辑，导致改一点就会引起新的问题，又要填补新的解决方案，反而被重构拖累，逐步更改的成本就会越来越高。
这是一个度的问题，但问题是，谁TM告诉我，这个度在哪里！！！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打算使用较为优秀的SDWebImage框架。Demo测试通过，开始集成到项目中。&lt;/p&gt;

&lt;p&gt;集成过程异常艰辛。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过pod包管理集成，出现异常。有重复类版本相撞无法通过编译。&lt;/li&gt;
&lt;li&gt;艰难查实的确存在，但置于一个叫MW&amp;hellip;的文件中的lib文件夹下。&lt;/li&gt;
&lt;li&gt;简单查阅叫MW&amp;hellip;这个鬼的用处，根本找不到用在哪，心好累，又不能直接暴力删除。也是够了！&lt;/li&gt;
&lt;li&gt;直接替换源码试试。 试验失败了，直接替换掉源码，导致另一些类报错，数目很多。估计是对源码进行了加工修改。只能放弃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;妥协方案，用较旧的三方暂时实现图片加载。&lt;/p&gt;

&lt;p&gt;失败：&lt;/p&gt;

&lt;p&gt;重新回到自适应上，虽然有了一套对于自适应使用的流程代码，但对于复杂又多类型又过于动态的列表仍旧不能适应。需要补充的判断实在是过于复杂，所以，这期自适应，预计将搁浅。&lt;/p&gt;

&lt;p&gt;先在较为简单的列表里试验，然后再着手处理复杂还多图的列表吧。&lt;/p&gt;

&lt;h3 id=&#34;2月18日-ui改造:08113914c16819b58c74ffda7bf76beb&#34;&gt;2月18日，UI改造。&lt;/h3&gt;

&lt;p&gt;改了快一天UI，感悟重申：想要一层层重构，最大的难点其实是对原代码的解读上。最大的成本也是。因为糟糕的代码配合特别动态的逻辑，衍生出来的复杂程度可见一斑。&lt;/p&gt;

&lt;p&gt;今天遇到的巨大的问题，更改一处UI，会衍生新的UI问题，更改新的UI问题，又可能会衍生出新的问题。遇到了重构需要换多少血才行，当然是全换最好，可时间和人力成本却不可负担。如果只是更换部分，就会引发多米骨牌，连续的问题会让重构变成焦油坑。&lt;/p&gt;

&lt;p&gt;iOS的视图，容器对控件或者父类视图对子类控制能力太弱。列表视图居然需要手动计算每个具体单元高度，这让我非常难以接受，如果计算出错，可能会导致上一个单元的内容遮盖下面单元格的内容，这点让我更加难以接受。同时也让我在进行抽离时，如履薄冰，不知道动哪里会影响到相关方法。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;大概遇到两个不得不思考解决的适应问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图片载入对UI刷新的影响。&lt;/li&gt;
&lt;li&gt;文字控件对文字是否能自适应高度。（文本控件居然没有一个属性，自适应高度。这不是刚需吗？程序设计应该要有的啊？想不明白！！！）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;UILabel的适应解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//初始化添加属性
label.numberOfLines = 0;
label.lineBreakMode = NSLineBreakByWordWrapping;

// 填入文字后添加
label.text = data.content
[label sizeToFit]

//注意：只有有宽度的label才能自动分行适应。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2月19日-继续改造-图片逻辑处理方案以及一些感想:08113914c16819b58c74ffda7bf76beb&#34;&gt;2月19日，继续改造（图片逻辑处理方案以及一些感想）&lt;/h3&gt;

&lt;p&gt;对图片进行改造。&lt;/p&gt;

&lt;p&gt;粗定一个图片改造计划。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;图片服务交给第三方，真的要交给第三方！现在三方对于图片的服务和管理真的已经很优秀了。我们是基于又拍云的服务提供。&lt;/p&gt;

&lt;p&gt;——血泪教训&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;不改动原先代码核心逻辑。一是平稳，而是原先代码的编写过于复杂，阅读成本就非常高，更改成本就更不可控了。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;原先的工具类，图片加载的方法需要传递八个参数。八个参数！八个参数！八个参数！真是疯了。这里犯了一个较为明显的错误，参数太多！&lt;/p&gt;

&lt;p&gt;方法参数是趋向于越少越好。参数目的是为了控制方法的实现能力，参数越多，实现的能力越强，但实现的情况和结果也越多，而且，每增加一个参数，对于实现出来的结果可能性都是成倍的增加，对修改成本也是很大，无从下手，也无法修改，巨大的不确定性，让这个方法理解和使用都有巨大的成本，对于随后维护的工程师更是大大大大的成本。&lt;/p&gt;

&lt;p&gt;所以，方法的参数，没有自然是最优。一个参数，很漂亮，也很自然，基本也不用具体看方法实现。两个参数，已经开始多重方向的控制了，有时需要进入方法具体实现查看。三个参数，必须进入方法具体实现来查看，而且，找三个参数扔进这个方法已经是高额成本了。四个参数，对不起，你写的这个方法有问题。&lt;/p&gt;

&lt;p&gt;当然，参数越积越多总是有原因的。一个很大的原因是，参数间本身是有关系，或者是协同一起去控制方法走向的，这时候，应该将几个协同合作的参数封装成一个类，以类的形式对外暴露。这是最直接也是最有效的重构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;只更改从又拍云上获得图片逻辑，并与原代码逻辑脱离，单独新建方法，并封装新类进行新的图片逻辑撰写。当然，新方法不支持从老式图片服务器拉图片。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;对旧系统的维护和支持要逐步进行替换和更迭。这两年花费了大量时间用户进行旧版本的适配支持，但淘汰率在时间上却很快。成本沉没率很高。现在想想也对，需要对旧版本进行适配和技术提供，就需要更多的时间去设计和修改问题，但这段时间里，新旧迭代的时间却也很快。大概最明显的例子，就是对于iOS 6789的支持了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;随后的新功能，新代码将缓存和加载这件事情上交给三方。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;随后会再写一篇文字，关于我们到底用不用开源，用多少好。都说适度的使用较好，尼玛！到底什么叫适度，我会写一篇自己的理解出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原本的代码是通过类扩展的方式实现的，所以直接在类扩展里加入了新的类扩展方式去实现。然后调用代码也简化了。基本功能已经跑通。&lt;/p&gt;

&lt;h3 id=&#34;2月20日-图片加载模块重构:08113914c16819b58c74ffda7bf76beb&#34;&gt;2月20日，图片加载模块重构&lt;/h3&gt;

&lt;p&gt;昨天已经跑通的基本功能，今天主要是对于图片加载重构的设计和规范。&lt;/p&gt;

&lt;p&gt;用了比较直接暴力的方法，直接引用使用，所有的缓存复用等交给依赖包。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;具体参考&lt;a href=&#34;图片加载设计和规范.md&#34;&gt;图片加载设计和规范&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后，便进入了重构过程中最最无聊的体力活阶段了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>美人鱼和周星驰</title>
      <link>https://zllbird.github.io/2016/02/17/%E7%BE%8E%E4%BA%BA%E9%B1%BC%E5%92%8C%E5%91%A8%E6%98%9F%E9%A9%B0/</link>
      <pubDate>Wed, 17 Feb 2016 19:48:42 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/02/17/%E7%BE%8E%E4%BA%BA%E9%B1%BC%E5%92%8C%E5%91%A8%E6%98%9F%E9%A9%B0/</guid>
      <description>

&lt;h2 id=&#34;则西-医疗-百度-责与罪:de921a30120fff62898217a2e947a485&#34;&gt;则西，医疗，百度，责与罪&lt;/h2&gt;

&lt;p&gt;风波一层过后，又来了一层。早上又一次看到新闻，看到知乎上对于广州那位被伤害的医生的讨论和评论。医疗问题再一次被推到风口浪尖上，也再一次让我思考和疼痛。我们眼下的医疗到底有多少毒在里面，然后，我们又到底该何去何从？
这篇文字还是只讨论则西事件，至于广州医生的事件，我仍需要一些补充一下事实再来讨论。
从我的角度出发，两点，&lt;strong&gt;责任和罪恶&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;先说责任。
十分制，武警医院3分，莆田系4分，政府相关2分，百度1分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这样写，估计很多人会先骂一顿，然后直接关掉网页了吧。只能先把下面的关于罪恶的评分也写上去，单纯的证明，我对百度的深恶痛绝。
罪恶十分，百度9分，剩下加起来还不如1分。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我是程序员，预期说太过于理性，不如说太过于现实。则西在知乎上那篇文字我很早就看到了，比这件事情还要早，则西将罪恶指向百度是事实，这点毋庸置疑，但莆田系和武警医院是也肯定是祸首，从责任上来讲，无论如何这两家都要付出绝对的代价。
先说医疗吧。三月四月我也基本全在医院，为治疗我父亲的癌症奔波，也同样失望绝望着，所以，我早早看到了则西死前的文字，不同说完全感同身受，但也的确历经着，有所感触。
先推荐几个我关注的人对于医疗方面的讨论。
&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MjM5ODQwMjA4MA==&amp;amp;mid=2649293393&amp;amp;idx=1&amp;amp;sn=0f8eb74168b13010537e2e16607856fe&amp;amp;scene=0#wechat_redirect&#34;&gt;可能吧-为甚了google没有虚假广告&lt;/a&gt;
&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzAwOTMwOTc3MA==&amp;amp;mid=2650482699&amp;amp;idx=1&amp;amp;sn=e129cd63ea8dbff64a47ffaacdd2ed78&amp;amp;scene=0#wechat_redirect&#34;&gt;君临-面对则西事件，李彦宏现在是什么状态，什么心情&lt;/a&gt;
他们说的很好，我心里有那么点思路，却完全组织不出来他们的语言来，索性便直接将链接引过来。
然后，说点切身的体会。在医院里吃住了近两个月，看到太多太多，其实有点心灰意冷，医生的圣洁之下，隐藏的太多罪与恶。也终于不得不明白，在中国（其实在整个世界上）看病是多么困难的一件事。
理性的讲，除了极个别名声在外的好医院外，中国剩下的医院基本都陷入了一种不得不的失责。由于政府对医院的甩手，医院需要自己满足收支平衡，让看病这个事儿，掺杂了生意成分进去。坦白说，生意场上，有大是大非，没有小善小恶，但医院里却有。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人可以有，小善小恶，因为人无完人。但人必须坚持，大是大非，因为需要配的起叫做人。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;医院的乱收费现象不用特别说明，几乎历经的人都明白。谋财这个事儿，是已经浮出来的事儿。这是劣根，很难改的。
坦白讲，有些事情，很荒诞，但我却是认得。我看病的时候，总是会碰见乱收费，医生也会多开些药，甚至只开些营养品，来增加医院和医生自己的收入，大多数情况下，只要不是很过分，即便我心里明白，仍然愿意为此买单。
你可能觉得这是‘助恶’，但实情是，就算名声在外的大医院（如协和医院），在收支上也是非常的微弱。
但这次武警医院和莆田系，真是给了我一计响亮的耳光。我一直以为，医院和医生，首先是为了给病人看病，然后再开一些营养品甚至开一些无关紧要的药来增加收入。而不是，就是为了贪念，为了挣钱，就是为了谋财，而不是为了看病。这不谋财害病，这真的不仅仅是恶，这是罪。底线的失守，让它彻底成为了毒瘤，恶心。
医院和医生，和普通职业是有区别的，它自带着一种契约精神，一种与生俱来的信任。
利用它来赚钱已经是失衡的恶，而破坏它去敛财，去谋财害命，是超出我认知的大罪，无法饶恕，不可原谅。
再说罪恶。
刚才我说，百度这事中责任不大，则西真正接触百度查找的时间应该不多，更多的是在医院里被折磨。所以说，就这件事来讲，百度是一分的责任。但，事情单纯拿出来说，就太苍白了。他这一分，是入口，是带着则西填入深渊的一分。
我问自己，这样子，真的只算一分吗？
就算我真的认，百度只有一分的责任的话。我仍然说，百度有9分的罪恶，是大罪，十恶不赦的那种。百度不是只为武警医院和莆田系的做虚假广告，百度的广告诟病太深，太沉重。毫不夸张的说，它是很多虚假广告的入口，医疗、教育、科技、社会等&amp;hellip;甚至，很多正规的企业或者公办处的电话，在百度提供出来的，都是虚假的&amp;hellip;只不过，医疗太过于敏感，被推到了公众前面罢了。
我不知道描绘的是不是清楚，但却绝对是一件细思恐怖的事情。如果把社会摊到面上来讲，各个事情都有着不同的负责或者祸首，但却有着一个相同的帮凶，不，准确说，一个相同的接引人。每个骗局里，每个罪恶里，你都能看到同一个名字出现在里面，关想到这里，我已经感到了莫大的恐怖，实在是想不下去了&amp;hellip;
所以，我除了厌恶百度，也真的恐惧百度。
一个企业，走到这里，真的是很糟糕。作为一个程序员，刚入行的时候，这个公司曾一度是我的理想目标之一。
沦落至此，让我不仅仅是同情与可悲，更有一种想除之后快的感觉。作为一个技术人，真的明白，用技术作恶是一件多么后怕的事情。尤其是一个已经失去了底线的公司&amp;hellip;
请远离百度，这是我的忠告。&lt;/p&gt;

&lt;p&gt;本来已经结束的文字，但在知乎上看到洗地的一系列后，我真的忍不住破口大骂。谷歌没有虚假广告吗？有，而且很多。谷歌里的人没有为了钱财而更改或者变相更改搜索结果排序吗？有，而且很多。但整个公司在努力的制止，整个公司在用各种监管来限制手下想谋财而更改排名，整个公司在修正着，所以谷歌说，Don&amp;rsquo;t be evil。
但百度不是，如果说谷歌是有恶，在修正的话，那么百度就是实打实的作恶！
&lt;strong&gt;这就是大罪，十罪不赦的那种！！！&lt;/strong&gt;
一个企业，做公关，谁都能理解。但，这样子去洗地，实在是。&lt;/p&gt;

&lt;p&gt;最后，我所能提出的建议，只能是远离。任何百度的产品都不去触碰。我甚至卸载了百度外卖，坦诚讲，我怕了，它没事，只是和百度沾上了，所以我怕了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>美人鱼和周星驰</title>
      <link>https://zllbird.github.io/2016/02/17/%E7%BE%8E%E4%BA%BA%E9%B1%BC%E5%92%8C%E5%91%A8%E6%98%9F%E9%A9%B0/</link>
      <pubDate>Wed, 17 Feb 2016 19:48:42 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/02/17/%E7%BE%8E%E4%BA%BA%E9%B1%BC%E5%92%8C%E5%91%A8%E6%98%9F%E9%A9%B0/</guid>
      <description>

&lt;h2 id=&#34;美人鱼和周星驰:a2af5027f0faa22ae57b2d151d2a1457&#34;&gt;美人鱼和周星驰&lt;/h2&gt;

&lt;p&gt;大年初一，便兴趣盎然的去看了——美人鱼。&lt;/p&gt;

&lt;p&gt;我是星爷的影迷，粉丝，脑残粉，（所以写这篇文字里基本都是各种顶膜崇拜），自然会在上映第一天就屁颠屁颠的去看了这部16年的大作，美人鱼。&lt;/p&gt;

&lt;p&gt;随后，回到家后，借着大年这些天无聊的时间，又陆陆续续的把功夫，喜剧之王，少林足球，大话西游再lu了一遍。看完后，脑子嗡嗡的，便写了这几个字。&lt;/p&gt;

&lt;p&gt;我依旧在豆瓣上给了5分，虽然我觉得它不值这个分数，大概也就4分，甚至不足4分，但我是脑残粉嘛。&lt;/p&gt;

&lt;p&gt;美人鱼开篇很多老梗，随后电影里很多很多老梗。开篇里，拿起咸鱼，然后馆长从浴缸里出水时那特渣的特效，都是以前影片里的影子。&lt;/p&gt;

&lt;p&gt;当我看到，珊刺杀富豪轩的那组戏时，我又无耻的笑了。尤其是看到，林子聪出来的那个瞬间，笑的我竟然感动了，（当年就是这个死胖子）。豆瓣说好多评价较低的说都是些老梗，这组戏应该是最为明显的了，功夫中林子聪也是这样，把我们的星爷扎的不要不要的。只不过这次是个女孩，看着还略微有点疼。&lt;/p&gt;

&lt;p&gt;说抄袭的&amp;hellip;一边去，自己抄自己的都叫抄袭了，你还要不要人家拍电影了&amp;hellip;&lt;/p&gt;

&lt;p&gt;说没创意的&amp;hellip;那要看你怎么定义创意了，如果非说从0到1是没创意。那我也觉得星爷这次这的没创意，不过星爷老了，我对这个有没有创意，要求不高。看完后我还是能哈哈笑出来，我就觉得挺好。&lt;/p&gt;

&lt;p&gt;珊和富豪在游乐场边吃烧鸡，飙歌那段，真的是满满的搞笑和纯爱。这种简单加暴力的方式去诠释纯爱和眷恋，简直就跟闹着玩似得。记得以前在一篇文字中看到，李安说周星驰总是弄一些小孩子的玩意。大概，就是说星爷这种闹着玩的把爱表达了吧。&lt;/p&gt;

&lt;p&gt;真的很喜欢这段，如果爱可以这么笑的看完，为啥非要那么多撕心裂肺呢。&lt;/p&gt;

&lt;p&gt;说完了好的，说点不好的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;期待本身就是最大的负担和失望。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;星爷这部电影，没那么好。尤其是又看了几部以前的电影，更加显得没那么好。美人鱼结尾的确有些凌乱，好多想表达的东西，都没表达出来。不够深刻，或者说，不够星爷的惯常的那种深刻。&lt;/p&gt;

&lt;p&gt;读懂了结局，读的太懂了，甚至还没来得及回味。这种感觉并不舒服。&lt;/p&gt;

&lt;p&gt;无论是大话西游还是喜剧之王，更不用说功夫。看完后，总有一些东西仿佛明白了，又仿佛还差那么一点点，忍不住想再看一遍。美人鱼缺的大概就是这种再来一遍的冲动。&lt;/p&gt;

&lt;p&gt;有人说，这是星爷境界太高，咱悟不到。也有人说，这是星爷返璞归真，无招胜有招。当然，也有人说，江郎才尽，思绪枯涸了，搞不出来了。&lt;/p&gt;

&lt;p&gt;聊两句我眼里的吧。&lt;/p&gt;

&lt;p&gt;无论我多么不愿意承认，星爷的巅峰的的确确已经过去了。喜剧之王和功夫，成就了太多东西，也压榨了太多。（这两部影片一直是我的大爱）&lt;/p&gt;

&lt;p&gt;也可以说，最让人敬畏的星爷和星爷的电影时代过去了。那敬畏之后呢？&lt;/p&gt;

&lt;p&gt;从星仔到星爷，创作或许是有起伏，但认真却是从一而终。星爷的认真，真真切切从未变过。也是这种奇怪的认真在里面，保证了星爷的作品只有两个档——优秀和卓越。&lt;/p&gt;

&lt;p&gt;这部美人鱼，真的称不上卓越，但说它优秀绝对没有问题。&lt;/p&gt;

&lt;p&gt;至于卓越嘛&amp;hellip;怎么讲呢？可遇不可求。因为在我看来，艺术上的卓越除了足够的实力和能力以外，还需要被长时间挤压的那种无法宣泄的灵感，在一次意外的碰撞后，喷涌而出，铸就卓越！&lt;/p&gt;

&lt;p&gt;所以，追求卓越本身就是一件很奢侈，也很痛快的事儿。&lt;/p&gt;

&lt;p&gt;而要求星爷的作品都卓越…也有点要求过高了&amp;hellip;&lt;/p&gt;

&lt;p&gt;但&amp;hellip;&lt;/p&gt;

&lt;p&gt;星爷下一部作品肯定是一部卓越的作品！因为&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;崇拜本身就是盲目的，不是吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2016.2.10&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>闭包，编程思考</title>
      <link>https://zllbird.github.io/2016/01/20/%E9%97%AD%E5%8C%85%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 20 Jan 2016 13:30:51 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/01/20/%E9%97%AD%E5%8C%85%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</guid>
      <description>

&lt;h2 id=&#34;闭包-编程思考:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;闭包，编程思考&lt;/h2&gt;

&lt;p&gt;缘由：经常会文章里看到闭包，对闭包有种感念，但有时候会绕进去。正好加上，android端的构建使用了gradle，gradle脚本基本上都是由闭包构成和撰写的，便研究了一番。更加巧合的是，参与iOS问题讨论的时候，发现了Block这种编写方式，越发觉得这些都是速途同归的玩意。&lt;/p&gt;

&lt;h3 id=&#34;摘要:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;摘要：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;闭包定义&lt;/li&gt;
&lt;li&gt;解读闭包&lt;/li&gt;
&lt;li&gt;闭包的意义&lt;/li&gt;
&lt;li&gt;不同语言对于闭包的另类实现&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;闭包定义:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;闭包定义&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Closure_(computer_programming&#34;&gt;Wiki上闭包的解读（很精彩）&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;闭包的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;closures&lt;/strong&gt; (also &lt;strong&gt;lexical closures&lt;/strong&gt; or &lt;strong&gt;function closures&lt;/strong&gt;) are a technique for implementing &lt;a href=&#34;https://en.wikipedia.org/wiki/Lexically_scoped&#34;&gt;lexically scoped&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Name_binding&#34;&gt;name binding&lt;/a&gt; in languages with &lt;a href=&#34;https://en.wikipedia.org/wiki/First-class_function&#34;&gt;first-class functions&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以给个中文版本的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解读闭包:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;解读闭包&lt;/h3&gt;

&lt;p&gt;好吧好吧，无论是英文还是中文，读起来感觉都特别的绕口，理解起来就更绕口了。&lt;/p&gt;

&lt;p&gt;还是直接暴力点吧，直接来代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;function startAt(x)
   function incrementBy(y)
       return x + y
   return incrementBy

variable closure1 = startAt(1)
variable closure2 = startAt(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;这是基于python的闭包的写法。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（在我的接触中，python语言是较为简单的，入门比较低，即便没有入门，看代码也不是困难，所以拿python举例，当然，建议大家都学学这个语言，一般一个星期写简单的程序就没问题了）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（python中，缩进代表 {} 符号）&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&#34;解读:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;解读：&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;startAt&lt;/code&gt;是一个函数，或者叫方法。它的返回值也是一个函数，或者叫，它返回一个函数类型的值。&lt;/p&gt;

&lt;p&gt;那么有意思的来了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;closure1(3) = 4
closure2(3) = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，&lt;code&gt;startAt&lt;/code&gt;到底是什么？&lt;/p&gt;

&lt;p&gt;解释它之前，先解释一下变量closure1 和变量 closure2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;closure1 = 1 + 参数
closure2 = 5 + 参数
//所以 closure2(3) = 5 + 3 = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发觉，&lt;code&gt;startAt&lt;/code&gt;是定义了一种加法。但属于它的变量&lt;code&gt;x&lt;/code&gt;却离开了&lt;code&gt;startAt&lt;/code&gt;一直和&lt;code&gt;closure1&lt;/code&gt;和&lt;code&gt;closure2&lt;/code&gt;存在，赶紧回去看一下刚才最初的定义。&lt;/p&gt;

&lt;p&gt;下面是我最喜欢的一段对于闭包的解读：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Closures are typically implemented with a special &lt;a href=&#34;https://en.wikipedia.org/wiki/Data_structure&#34;&gt;data structure&lt;/a&gt; that contains a &lt;a href=&#34;https://en.wikipedia.org/wiki/Function_pointer&#34;&gt;pointer to the function code&lt;/a&gt;, plus a representation of the function&amp;rsquo;s lexical environment (i.e., the set of available variables) at the time when the closure was created. The referencing environment &lt;a href=&#34;https://en.wikipedia.org/wiki/Name_binding&#34;&gt;binds&lt;/a&gt; the non-local names to the corresponding variables in the lexical environment at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is *entered* at a later time, possibly with a different lexical environment, the function is executed with its non-local variables referring to the ones captured by the closure, not the current environment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;闭包的意义:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;闭包的意义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;因为闭包只有在被调用时才执行操作，即“&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&#34;&gt;惰性求值&lt;/a&gt;”，所以它可以被用来定义控制结构。例如：在&lt;a href=&#34;https://zh.wikipedia.org/wiki/Smalltalk&#34;&gt;Smalltalk&lt;/a&gt;语言中，所有的控制结构，包括分歧条件(if/then/else)和循环(while和for)，都是通过闭包实现的。用户也可以使用闭包定义自己的控制结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;感受一下，一会儿看到各个语言的实现，就能有那种醍醐灌顶的感觉了。&lt;/p&gt;

&lt;h3 id=&#34;不同语言对于闭包的另类实现:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;不同语言对于闭包的另类实现&lt;/h3&gt;

&lt;p&gt;解读完闭包了，聊一下，这个玩意最大的问题是什么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt; &amp;ndash;&amp;gt; 自由变量的作用域，导致自由变量的混乱管理。&lt;/p&gt;

&lt;p&gt;我将先以&lt;code&gt;javascript&lt;/code&gt;为例，介绍最大的问题。&lt;/p&gt;

&lt;p&gt;然后，我再会分别介绍一下&lt;code&gt;java&lt;/code&gt;以及&lt;code&gt;Object-C&lt;/code&gt;为例子，解释一下其他语言是如何另类实现闭包，并怎么处理作用域的问题。&lt;/p&gt;

&lt;h4 id=&#34;javascript-的闭包:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;&lt;code&gt;javascript&lt;/code&gt;的闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// ECMAScript , javascript
var f, g;
function foo() {
  var x; // 
  f = function() { x = x + 1 ; return x; }; //
  g = function() { x = x +5 ; return x; };	//
  x = 1;
  alert(&#39;inside foo, call to f(): &#39; + f()); // 2
}
foo();
alert(&#39;call to g(): &#39; + g());  // 7
alert(&#39;call to f(): &#39; + f());  // 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到结果为。&lt;/p&gt;

&lt;p&gt;如果我将输出顺序换一下呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;alert(&#39;call to f(): &#39; + f()); // 3
alert(&#39;call to g(): &#39; + g()); // 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给你们两分钟时间，再想一下。&lt;/p&gt;

&lt;p&gt;可以看到。在&lt;code&gt;foo&lt;/code&gt;中声明的变量&lt;code&gt;x&lt;/code&gt;，由于闭包的存在，导致&lt;code&gt;x&lt;/code&gt;的作用域一直扩展到程序的底部，在&lt;code&gt;foo&lt;/code&gt;函数结束后还一直坚挺的活着。（这是我们刚才已经知道了的。）&lt;/p&gt;

&lt;p&gt;不仅活着，还可以被更改，然后再使用！&lt;/p&gt;

&lt;p&gt;那么问题到底是什么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;难以管理。&lt;/li&gt;
&lt;li&gt;持有。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;java-以及-object-c-对闭包的-实现:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;&lt;code&gt;JAVA&lt;/code&gt; 以及&lt;code&gt;Object-C&lt;/code&gt;对闭包的‘实现’&lt;/h3&gt;

&lt;p&gt;直接说，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java&lt;/code&gt;中是 匿名内部类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object-c&lt;/code&gt;中是 Block运用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以基于这点来讲，&lt;code&gt;java&lt;/code&gt;更加面向对象一点，真的是很努力做到一切都是对象了。&lt;/p&gt;

&lt;p&gt;先看一下&lt;code&gt;java&lt;/code&gt;代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void foo(){
   final int x = 1 ; //

  //f(lambda (x) -&amp;gt; person.setAge(x));

  f(new OnChangListner(){
  		void onChang(){
  			person.setAge(x);
		}
	});

  // 当然方法f必须事先定义好
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再看一下&lt;code&gt;object-c&lt;/code&gt;的BLOCK:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)foo {
    NSInteger x = 1;

    void (^f) (NSInteger *) = ^(NSInteger *x)
    {
      x = 4; // 异常  
      NSLog(@&amp;quot;foodname:%@&amp;quot;, x);
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思吧。&lt;/p&gt;

&lt;p&gt;这样既能完成传值，又成功的避开了作用域的问题。&lt;/p&gt;

&lt;p&gt;当然，本质上来讲，这已经不是闭包了。&lt;code&gt;java&lt;/code&gt;里&lt;code&gt;onChang&lt;/code&gt;中的&lt;code&gt;x&lt;/code&gt;和定义的&lt;code&gt;x&lt;/code&gt;其实已经不是一个内存了，而我们需要的不是一个内存，而是一个相同的值。&lt;/p&gt;

&lt;p&gt;这也是我为什么将实现两个字打上了引号。&lt;/p&gt;

&lt;p&gt;贴一下对于其他语言对于‘类’闭包的结构或者设计：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Callbacks (C)
Local classes and Lambda functions (Java)
Blocks (C, C++, Objective-C 2.0)
Delegates (C#, D)
Function objects (C++)
Inline agents (Eiffel)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思考:9832bcef4d84f38f7ad4bc607eea0d15&#34;&gt;思考&lt;/h3&gt;

&lt;p&gt;说两句感悟，大家随便感受一下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所谓的设计模式也好，这种和闭包语法类似的东西也好。原因大多不是语言设计者要装x而搞出来的，大多数都是因为，内建不够。一个语言设计模式越多，或者说，为了一种实现折腾的过程越多，其实越代表语言的局限性越大。&lt;/li&gt;
&lt;li&gt;因为同时兼顾Android和iOS开发，所以可以明显感觉到，&lt;code&gt;object-c&lt;/code&gt;的限制太多，或者说内建较差。所以才有swift，我也简单学习了swift的基础语法，可以说内建相当的不错。当然，java也不怎么样，新兴的很多语言对于设计要比java优秀很多（比如，方法可以多个返回）。&lt;/li&gt;
&lt;li&gt;学习其他语言。比我们想象的要简单的多。（抽空单独出文章）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;mdash;-—-&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Android】使用Gradle进行配置</title>
      <link>https://zllbird.github.io/2016/01/14/android%E4%BD%BF%E7%94%A8gradle%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 14 Jan 2016 18:20:35 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/01/14/android%E4%BD%BF%E7%94%A8gradle%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE/</guid>
      <description>

&lt;h2 id=&#34;android-使用gradle进行配置-记录:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;【Android】使用Gradle进行配置（记录）&lt;/h2&gt;

&lt;h3 id=&#34;摘要:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;摘要&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;需求&lt;/li&gt;
&lt;li&gt;配置工程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;概念介绍:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;概念介绍&lt;/h3&gt;

&lt;p&gt;直接推荐几篇文章入门。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://android.jobbole.com/81436/&#34;&gt;深入理解Android的Gradle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pkaq.github.io/gradledoc/docs/userguide/userguide.html&#34;&gt;Gradle 用户手册（含部分翻译）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ADT已经不在继续更新了。自然而然的，Android Studio成了新贵。虽说还是有一些别的IDE和别的方式去编写和构建Android，但由于谷歌的维护和升级，AS成了绝大多数Android开发者的选择。对于小团队来说（本人就是在小小小团队），AS + GRADLE 成了现阶段主流。&lt;/p&gt;

&lt;p&gt;这是记录，所以概念型的东西就不做介绍了。&lt;/p&gt;

&lt;h3 id=&#34;需求:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;需求&lt;/h3&gt;

&lt;p&gt;由于团队本身有好多服务器（*开发，灰度，线上*），再加上有很多三方的引用（如：我们团队IM引用了环信），另外还有一些日志系统的调控等，再加上长时间不同人员对代码开发，导致这些配置非常混乱，散落于不同的类，还有一些在&lt;code&gt;AndroidManifies.xml&lt;/code&gt;等文件中，所以导致导报经常会出现一些莫名其妙的错误。&lt;/p&gt;

&lt;p&gt;需求：实现 &amp;gt; 能合理地配置这些，并使用配置文件进行统一管理 &amp;gt;的需求。&lt;/p&gt;

&lt;p&gt;目标如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;只需更改一处（一行）就能实现不同需求打包的切换！（最重要）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;不影响Studio相关联的&lt;code&gt;gradle&lt;/code&gt;文件（&lt;code&gt;build.gradle&lt;/code&gt;一旦改变，就会导致重新编译），但又可以及时更改相关配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;配置工程:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;配置工程&lt;/h3&gt;

&lt;h4 id=&#34;配置-buildconfig:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;配置&lt;code&gt;BuildConfig&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;BuildConfig&lt;/code&gt; 这个类是工程自动构建生成的。可以具体看一下这个类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Automatically generated file. DO NOT MODIFY
 */
package ****;

public final class BuildConfig {
  public static final boolean DEBUG = Boolean.parseBoolean(&amp;quot;true&amp;quot;);
  public static final String APPLICATION_ID = &amp;quot;**.builddemo&amp;quot;;
  public static final String BUILD_TYPE = &amp;quot;debug&amp;quot;;
  public static final String FLAVOR = &amp;quot;&amp;quot;;
  public static final int VERSION_CODE = 1;
  public static final String VERSION_NAME = &amp;quot;1.0&amp;quot;;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释说：这个类是自动生成的，别动，动了也没什么用~~~&lt;/p&gt;

&lt;p&gt;然后可以看到，这里&lt;code&gt;DEBUG&lt;/code&gt;,&lt;code&gt;APPLICATION_ID&lt;/code&gt;,&lt;code&gt;BUILD_TYPE&lt;/code&gt;,&lt;code&gt;FLAVOR&lt;/code&gt;,&lt;code&gt;VERSION_CODE&lt;/code&gt;,&lt;code&gt;VERSION_NAME&lt;/code&gt;这些常量，这些常量有的是我们在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中配置的，有些是我们在module下的&lt;code&gt;build.grade&lt;/code&gt;中配置的（当然，这些其实全部可以在&lt;code&gt;build.gradle&lt;/code&gt;中进行配置）&lt;/p&gt;

&lt;p&gt;就像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;android {
    compileSdkVersion 23
    buildToolsVersion &amp;quot;23.0.2&amp;quot;

    defaultConfig {
        applicationId &amp;quot;**.builddemo&amp;quot;
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName &amp;quot;1.0&amp;quot;
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-	rules.pro&#39;
        }
    }

    productFlavors {
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于工程中需要&lt;code&gt;versionCode&lt;/code&gt;参数，所以&lt;code&gt;BuildConfig&lt;/code&gt;便提供了很大的便利。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tip: defaultConfig{} 这个闭包就是配置工程参数的，也就是直接对应&lt;code&gt;BuildConfig&lt;/code&gt;的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;既然如此，如果能给&lt;code&gt;BuildConfig&lt;/code&gt;配置自定义的参数，那么需求就解决了一半了！&lt;/p&gt;

&lt;p&gt;显然，Android团队也肯定会留下一些自定义的API，保证大家能  “ 随便乱搞”。&lt;/p&gt;

&lt;p&gt;下面是自定义API写法和使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;defaultConfig {
  
       ...
  
		// 自定义的方法就是 buildConfigField ，这种是groovy写法
        // 三个参数分别是 type (类型) ， name (命名) ， value(值)
        buildConfigField &#39;int&#39; , &#39;SEVER_CONFIG&#39; , &amp;quot;1&amp;quot;
  		
  		// 当然写成这种更容易看懂,这种写法更像java。
  		// 三个参数分别是 type (类型) ， name (命名) ， value(值)
  		buildConfigField(&amp;quot;int&amp;quot; , &amp;quot;SEVER_CONFIG&amp;quot; , &amp;quot;1&amp;quot;)
  
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新构建后，可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class BuildConfig {
  public static final boolean DEBUG = Boolean.parseBoolean(&amp;quot;true&amp;quot;);
  public static final String APPLICATION_ID = &amp;quot;**.builddemo&amp;quot;;
  public static final String BUILD_TYPE = &amp;quot;debug&amp;quot;;
  public static final String FLAVOR = &amp;quot;&amp;quot;;
  public static final int VERSION_CODE = 1;
  public static final String VERSION_NAME = &amp;quot;1.0&amp;quot;;
  // Fields from default config.
  public static final int SEVER_CONFIG = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;int SEVER_CONFIG = 1;&lt;/code&gt; 正好对应 &lt;code&gt;&#39;int&#39; , &#39;SEVER_CONFIG&#39; , &amp;quot;1&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意， “1” 对应的是 1 ， ’ “1” ‘ 对应的是 “1”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是不是很简单。&lt;/p&gt;

&lt;p&gt;简单看一下原理吧。&lt;/p&gt;

&lt;p&gt;原来是本身构建的时候，android会将闭包转化成相关类，并调用方法。可以看一下&lt;code&gt;buildConfigField&lt;/code&gt;这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// -- DSL Methods. TODO remove once the instantiator does what I expect it to do.

    /**
     * Adds a new field to the generated BuildConfig class.
     *
     * The field is generated as:
     *
     * &amp;lt;type&amp;gt; &amp;lt;name&amp;gt; = &amp;lt;value&amp;gt;;
     *
     * This means each of these must have valid Java content. If the type is a String, then the
     * value should include quotes.
     *
     * @param type the type of the field
     * @param name the name of the field
     * @param value the value of the field
     */
    public void buildConfigField(
            @NonNull String type,
            @NonNull String name,
            @NonNull String value) {
        ClassField alreadyPresent = getBuildConfigFields().get(name);
        if (alreadyPresent != null) {
            String flavorName = getName();
            if (BuilderConstants.MAIN.equals(flavorName)) {
                logger.info(
                        &amp;quot;DefaultConfig: buildConfigField &#39;{}&#39; value is being replaced: {} -&amp;gt; {}&amp;quot;,
                        name, alreadyPresent.getValue(), value);
            } else {
                logger.info(
                        &amp;quot;ProductFlavor({}): buildConfigField &#39;{}&#39; &amp;quot;
                                + &amp;quot;value is being replaced: {} -&amp;gt; {}&amp;quot;,
                        flavorName, name, alreadyPresent.getValue(), value);
            }
        }
        addBuildConfigField(AndroidBuilder.createClassField(type, name, value));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;code&gt;ProductFlavor&lt;/code&gt;这个类里的方法，不详细说了，大家其实直接看注释就ok了。&lt;/p&gt;

&lt;h4 id=&#34;解决-androidmanifest-xml-的-meta-data-等:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;解决&lt;code&gt;AndroidManifest.xml&lt;/code&gt;的&lt;code&gt;Meta-data&lt;/code&gt;等&lt;/h4&gt;

&lt;p&gt;拿&lt;code&gt;AndroidManifest.xml&lt;/code&gt;的&lt;code&gt;Meta-data&lt;/code&gt;出来说，其实别的字段也是一样的。&lt;/p&gt;

&lt;p&gt;还是&lt;code&gt;build.gradle&lt;/code&gt;中的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;defaultConfig {
    applicationId &amp;quot;zhulonglong.builddemo&amp;quot;
    minSdkVersion 15
    targetSdkVersion 23
    versionCode 1
    versionName &amp;quot;1.0&amp;quot;

    buildConfigField &#39;int&#39; , &#39;SEVER_CONFIG&#39; , &amp;quot;1&amp;quot;
    manifestPlaceholders = [ CHANNEL_VALUE : &amp;quot;QQ&amp;quot; ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的&lt;code&gt;AndroidManifest.xml&lt;/code&gt;的&lt;code&gt;Meta-data&lt;/code&gt;数据是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;application
        android:allowBackup=&amp;quot;true&amp;quot;
        android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;
        android:label=&amp;quot;@string/app_name&amp;quot;
        android:supportsRtl=&amp;quot;true&amp;quot;
        android:theme=&amp;quot;@style/AppTheme&amp;quot;&amp;gt;

       ...
        &amp;lt;meta-data android:name=&amp;quot;CHANNEL&amp;quot;
                   android:value=&amp;quot;${CHANNEL_VALUE}&amp;quot;/&amp;gt;
&amp;lt;/application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;${}&lt;/code&gt;是替代符，在&lt;code&gt;defaultConfig&lt;/code&gt;中&lt;code&gt;manifestPlaceholders&lt;/code&gt;便是对应的AndroidManifest.xml配置文件。&lt;/p&gt;

&lt;h4 id=&#34;合并-新建-config-gradle-统一管理所有的配置:b2d32e58210a46d52cedf8f96f12aada&#34;&gt;合并，新建&lt;code&gt;config.gradle&lt;/code&gt;统一管理所有的配置&lt;/h4&gt;

&lt;p&gt;创建一个&lt;code&gt;config.gradle&lt;/code&gt;的好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无缝衔接&lt;code&gt;gradle&lt;/code&gt;构建系统&lt;/li&gt;
&lt;li&gt;android studio 方便查看更改，且不会引起重新构建（IDE 自动识别的都是&lt;code&gt;build.gradle&lt;/code&gt;文件，对于别的gradle文件不会在乎）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我创建的&lt;code&gt;config.grade&lt;/code&gt;是在项目根录下的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;
def DEV = 0
def ONLINE = 2

ext{
    SEVER_CONFIG = ONLINE
    CHANNEL_DEV = &amp;quot;CHANNEL_DEV&amp;quot;
    CHANNEL_ONLINE = &amp;quot;CHANNEL_ONLINE&amp;quot;

    if (SEVER_CONFIG == DEV){
        CHANNEL_NAME = CHANNEL_DEV
    }else {
        CHANNEL_NAME = CHANNEL_ONLINE
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ext&lt;/code&gt;保证了别的&lt;code&gt;gradle&lt;/code&gt;能顺利使用这个属性&lt;/p&gt;

&lt;p&gt;在需要的&lt;code&gt;build.gradle&lt;/code&gt;中导入&lt;code&gt;config.gradle&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply from: rootProject.getRootDir().getAbsolutePath() + &amp;quot;/config.gradle&amp;quot;

println &amp;quot;Project Name &amp;quot; + getName()
println &amp;quot;Project Path &amp;quot; + getPath()

android {
    compileSdkVersion 23
    buildToolsVersion &amp;quot;23.0.2&amp;quot;

    defaultConfig {
        applicationId &amp;quot;**.builddemo&amp;quot;
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName &amp;quot;1.0&amp;quot;

        buildConfigField &#39;int&#39; , &#39;SEVER_CONFIG&#39; , &amp;quot;${SEVER_CONFIG}&amp;quot;

        manifestPlaceholders = [ CHANNEL_VALUE : &amp;quot;${CHANNEL_NAME}&amp;quot; ]

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }

    productFlavors {


    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以直接引用这个属性了。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildConfigField &#39;int&#39; , &#39;SEVER_CONFIG&#39; , &amp;quot;${SEVER_CONFIG}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SEVER_CONFIG&lt;/code&gt;就是在&lt;code&gt;config.gradle&lt;/code&gt;中定义的。&lt;/p&gt;

&lt;p&gt;到此为止，目的达到了。&lt;/p&gt;

&lt;p&gt;所有的配置都在文件&lt;code&gt;config.gradle&lt;/code&gt;中进行更改。当然，还需要在里面定义一个总开关，将具体参数配置分块。&lt;/p&gt;

&lt;p&gt;在代码中可以直接使用&lt;code&gt;BuildConfig&lt;/code&gt;进行相关使用。&lt;/p&gt;

&lt;p&gt;当然，更改&lt;code&gt;config.gradle&lt;/code&gt;不会进行重新构建，是不是棒棒哒！！！&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>关于苹果证书</title>
      <link>https://zllbird.github.io/2016/01/11/%E5%85%B3%E4%BA%8E%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Mon, 11 Jan 2016 20:43:23 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/01/11/%E5%85%B3%E4%BA%8E%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6/</guid>
      <description>

&lt;h2 id=&#34;关于苹果证书:e17706f6098990c313a029f4b1ce2f78&#34;&gt;关于苹果证书&lt;/h2&gt;

&lt;h3 id=&#34;摘要:e17706f6098990c313a029f4b1ce2f78&#34;&gt;摘要：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;苹果证书简介&lt;/li&gt;
&lt;li&gt;具体解读&lt;/li&gt;
&lt;li&gt;如何优雅地使用&lt;/li&gt;
&lt;li&gt;关于苹果证书企业版的那些事儿&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;苹果证书简介:e17706f6098990c313a029f4b1ce2f78&#34;&gt;苹果证书简介&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;开发者证书（分为开发和发布两种，类型为&lt;strong&gt;ios Development,ios Distribution&lt;/strong&gt;），这个是最基础的，不论是真机调试，还是上传到appstore都是需要的，是一个基证书，用来证明自己开发者身份的。&lt;/li&gt;
&lt;li&gt;appID,这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了PassBook,GameCenter,以及更常见的push服务，如果选中了push服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的appID。&lt;/li&gt;
&lt;li&gt;推送证书（分为开发和发布两种，类型分别为&lt;strong&gt;APNs Development ios,APNs Distribution ios&lt;/strong&gt;）,该证书在appID配置中创建生成，和开发者证书一样，安装到开发电脑上；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Provisioning Profiles&lt;/strong&gt;,这个东西是很有苹果特色的一个东西，我一般称之为PP文件，该文件将appID,开发者证书，硬件Device绑定到一块儿，在开发者中心配置好后可以添加到Xcode上，也可以直接在Xcode上连接开发者中心生成，真机调试时需要在PP文件中添加真机的udid；是真机调试和必架必备之珍品&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;具体解读:e17706f6098990c313a029f4b1ce2f78&#34;&gt;具体解读&lt;/h3&gt;

&lt;p&gt;首先先说一下，苹果账号分两种，一种是$99 ,另一种是$299。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$99&lt;/strong&gt;，个人或公司账号。可发布到App Store，这是最重要的。但不可以无限给设备分发，只能分发100个设备，根据UUID来唯一识别设备。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$299&lt;/strong&gt;，企业账号。&lt;strong&gt;不可以发布到App Store&lt;/strong&gt;，这是最重要的。但可以无限分发，无限分发，无限分发。（但iOS的企业开发者信任调整了，所以虽可以任意分发，但需要安装后，手动在设置里先信任开发者，这点很讨厌）&lt;/p&gt;

&lt;p&gt;然后开始解读上面提到的四种证书，先上图看一下，开发者中心的目录解读。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ok，基础了解之后。具体讲述一下，这堆乱起八糟的东西到底有什么用。&lt;/p&gt;

&lt;p&gt;苹果为了保证开发者（就是交完钱的孩子），能安安全全的开发，开开心心的发布，而不交钱的孩子开发都比较困难，所以搞出了这一大套折腾的东西。&lt;/p&gt;

&lt;h5 id=&#34;certificates-appid-bundle-id-provisioning-profiles-到底是怎么用的呢:e17706f6098990c313a029f4b1ce2f78&#34;&gt;Certificates，AppID(Bundle id)，Provisioning Profiles 。到底是怎么用的呢？&lt;/h5&gt;

&lt;p&gt;Provisioning Profiles，可以理解为安装到苹果设备的认证，通俗讲就是能不能安装到苹果设备，就看Provisioning Profiles这把钥匙能不能用。能用，进门安装。不能，弹出一个提示&lt;strong&gt;无法安装&lt;/strong&gt;，就呵呵哒了。&lt;/p&gt;

&lt;p&gt;既然如此，怎样才能生成一个Provisioning Profiles呢。看一下苹果这边生成Provisioning Profiles需要什么？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;终于好了，将证书Certificates，AppID(Bundle id)，devices都选择完后，绑定到一起，成功召唤出神龙，帮你生成了这把钥匙。&lt;/p&gt;

&lt;p&gt;那这把钥匙到底开的是哪扇门呢？&lt;strong&gt;是代码，是代码，是代码&lt;/strong&gt;！！！&lt;/p&gt;

&lt;p&gt;看一下打包的时候，在哪里用到这个签名，在build setting 下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意左上角是代码签名，代码签名！&lt;/p&gt;

&lt;p&gt;所以上面那个图告诉我们的是，谁（*iOS Developer 或者iPhone Distribution*）给这段代码签名了，然后并配上了一把钥匙（Provisioning Profiles 描述文件，可以打开app store上的app，或者 可以打开  XC:AD HOC 私下分发的app等），共同组合一起完成了一个叫扩张名为ipa的打包文件。&lt;/p&gt;

&lt;h3 id=&#34;如何优雅地使用:e17706f6098990c313a029f4b1ce2f78&#34;&gt;如何优雅地使用&lt;/h3&gt;

&lt;p&gt;有这段主要是由于本公司混乱和冗余的证书把整个开发者中心搞得&amp;hellip;简直就是乌烟瘴气。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Certificates 是一定要通过电脑生成证书，然后提交网页签名的。所以，命名一定要特别的长，长到把此证书是何用，用在何处的信息尽量多的写。&lt;/li&gt;
&lt;li&gt;appID ，也是有备注名的，备注名的，备注名的。所以，还是尽量多的写，尽量多的写。&lt;/li&gt;
&lt;li&gt;Provisioning Profiles，尽量不要在网页生成下载，建议直接用Xcode生成。&lt;/li&gt;
&lt;li&gt;协同开发者，下载Provisioning Profiles一定要用Xcode的account管理，一键下载安装。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（选择xcode —&amp;gt; prefenerces—&amp;gt;accounts—&amp;gt;view details）&lt;/p&gt;

&lt;p&gt;这里就可以下载所有的profiles。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;关于苹果证书企业版的那些事儿:e17706f6098990c313a029f4b1ce2f78&#34;&gt;关于苹果证书企业版的那些事儿&lt;/h3&gt;

&lt;p&gt;刚才提到过，企业版证书就是价值299美元的那个。&lt;/p&gt;

&lt;p&gt;和普通版本没有什么大的区别，就是Provisioning Profiles的生成中多了一个叫做&lt;code&gt;in-house&lt;/code&gt;的发布类型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;只有这一点区别。&lt;/p&gt;

&lt;p&gt;看一下生成后的描述文件有哪里不一样。可以看到类型不一样！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然，打包的时候，build setting 中也要同时选中这个版的Provisioning Profiles。&lt;/p&gt;

&lt;p&gt;然后选择&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/apple_cerreq/apple_cerreq_9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>CocoaLumberjack的集成和学习</title>
      <link>https://zllbird.github.io/2016/01/09/cocoalumberjack%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 09 Jan 2016 14:59:57 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2016/01/09/cocoalumberjack%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E5%AD%A6%E4%B9%A0/</guid>
      <description>

&lt;h2 id=&#34;cocoalumberjack的集成和学习:43299706702588eefa55b6be9b7526b3&#34;&gt;CocoaLumberjack的集成和学习&lt;/h2&gt;

&lt;h3 id=&#34;摘要:43299706702588eefa55b6be9b7526b3&#34;&gt;摘要：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;介绍以及安装&lt;/li&gt;
&lt;li&gt;集成&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;介绍以及安装:43299706702588eefa55b6be9b7526b3&#34;&gt;介绍以及安装&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/CocoaLumberjack/CocoaLumberjack&#34;&gt;GitHub地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;强烈建议好好通过Github上的方式安装和使用，github是神器，好好使用，总会飞升。&lt;/p&gt;

&lt;p&gt;CocoaLumberjack，简单说就是日志系统。对于我这种原来是java的工程师来说，就是log4j。之所以使用它，是我对于XCode的极大不满！（打印日志居然没有颜色，而且&amp;hellip;地方那么小，我有两个屏幕有个毛线用。）吐槽结束，说两句CocoaLumberjack特点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有分级。能分级打印的日志才叫日志，才能有选择的看嘛。&lt;/li&gt;
&lt;li&gt;能通过插件配色。&lt;strong&gt;全是一个颜色的日志找起来，真的好辛苦&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;能自定义日志输出信息。&lt;strong&gt;有调用类，调用方法，调用行数的日志才是好的日志&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;安装:43299706702588eefa55b6be9b7526b3&#34;&gt;安装&lt;/h4&gt;

&lt;p&gt;请先通过Github上的介绍安装。~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;建议建议：&lt;/strong&gt; 使用CocoaPods来安装。只需要在&lt;code&gt;Podfile&lt;/code&gt;上填上两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;platform :ios, &#39;7.0&#39;
pod &#39;CocoaLumberjack&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后终端执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就完成了。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;ok，ok，ok….这里肯定会有几个坑。简单说一下。&lt;/p&gt;

&lt;h4 id=&#34;坑:43299706702588eefa55b6be9b7526b3&#34;&gt;坑：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;请在翻墙的环境下安装。相信我，如果没有翻墙环境，你总会陷入莫名的长时间等待。&lt;/li&gt;
&lt;li&gt;安装过程中，一旦出现以下情况。&lt;img src=&#34;https://zllbird.github.io/images/cocoaLumberjack/1.png&#34; alt=&#34;&#34; /&gt;说明安装并没有成功配置。原因是原来的项目由于各种原因，导致管理的包路径，源路径很有问题，需要根据上述提示进行更改。（这里会经常出问题，都是因为大家习惯了直接将问题放到google或者&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;stackoverflow&lt;/a&gt;找寻答案，本人不建议如此做，先看日志输出，搞清楚到底啥问题才是最重要的），接下来截图是我的修改，本质上就是按照提示进行更改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/cocoaLumberjack/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/cocoaLumberjack/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CocoaPods本身对源码入侵是比较严重的，所以大家也可以使用Carthage。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;集成:43299706702588eefa55b6be9b7526b3&#34;&gt;集成&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;集成也很简单，仍然是建议大家先通过英文文档。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为我正在使用的工程还有&lt;code&gt;.pch&lt;/code&gt;预加载头文件的存在，所以我仍然是在这里配置了我的输入和输出等级。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#ifdef DEBUG
    static const DDLogLevel ddLogLevel = DDLogLevelDebug;
#else
    static const DDLogLevel ddLogLevel = DDLogLevelError;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这种方式正在被淘汰，建议大家可以写到一个宏来配置。&lt;/p&gt;

&lt;p&gt;然后在&lt;code&gt;AppDelegate&lt;/code&gt;中的&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;中初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &amp;lt;CocoaLumberjack/CocoaLumberjack.h&amp;gt;

...
...
...

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
 	[DDLog addLogger:[DDTTYLogger sharedInstance]];
 	[DDLog addLogger:[DDASLLogger sharedInstance]];

    [[DDTTYLogger sharedInstance] setLogFormatter:[LDFormatter new]];
    // And we also enable colors
    [[DDTTYLogger sharedInstance] setColorsEnabled:YES];

    DDFileLogger *fileLogger = [[DDFileLogger alloc] init]; // File Logger
    fileLogger.rollingFrequency = 60 * 60 * 24; // 24 hour rolling
    fileLogger.logFileManager.maximumNumberOfLogFiles = 7;

    [DDLog addLogger:fileLogger];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成初始化后，就可以在想要的敌方直接打印结果了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	DDLogVerbose(@&amp;quot;Verbose&amp;quot;);
    DDLogDebug(@&amp;quot;Debug&amp;quot;);
    DDLogInfo(@&amp;quot;Info&amp;quot;);
    DDLogWarn(@&amp;quot;Warn&amp;quot;);
    DDLogError(@&amp;quot;Error&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用:43299706702588eefa55b6be9b7526b3&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;其实到上面为止，使用也已经是说完了。但对于工程来说，打印日志，只有日志信息是不够的。CocoaLumberjack对此做了非常好的优化，只需要简单地配置就基本可以打印出一个较为理想的日志输出。（也就是我开始讲的第3条）&lt;/p&gt;

&lt;h4 id=&#34;配置自定义的formatter:43299706702588eefa55b6be9b7526b3&#34;&gt;&lt;strong&gt;配置自定义的Formatter&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;配置之前，可以先给大家看一下，CocoaLumberjack的日志到底包含了多少信息，有多强大。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface DDLogMessage : NSObject &amp;lt;NSCopying&amp;gt;
{
    // Direct accessors to be used only for performance
    @public
    NSString *_message;
    DDLogLevel _level;
    DDLogFlag _flag;
    NSInteger _context;
    NSString *_file;
    NSString *_fileName;
    NSString *_function;
    NSUInteger _line;
    id _tag;
    DDLogMessageOptions _options;
    NSDate *_timestamp;
    NSString *_threadID;
    NSString *_threadName;
    NSString *_queueLabel;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，无论是类（&lt;code&gt;_fileName&lt;/code&gt;），还是函数名（&lt;code&gt;_function&lt;/code&gt;）,还有所在的行数（&lt;code&gt;_line&lt;/code&gt;），还有时间，所在线程等等等等，都有。&lt;/p&gt;

&lt;p&gt;接下来就可以自定义Formatter了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;建议大家还是先看Github项目中的自定义&lt;a href=&#34;https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomFormatters.md&#34;&gt;Formatter文档&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyFormatter.h

@interface MyFormatter : NSObject &amp;lt;DDLogFormatter&amp;gt; {
    int loggerCount;
    NSDateFormatter *threadUnsafeDateFormatter;
}
@end


=======

MyFormatter.m

@implementation MyFormatter

- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
    NSString *logLevel;
    switch (logMessage-&amp;gt;_flag) {
        case DDLogFlagError    : logLevel = @&amp;quot;Error&amp;quot;; break;
        case DDLogFlagWarning  : logLevel = @&amp;quot;W&amp;quot;; break;
        case DDLogFlagInfo     : logLevel = @&amp;quot;Info&amp;quot;; break;
        case DDLogFlagDebug    : logLevel = @&amp;quot;D&amp;quot;; break;
        default                : logLevel = @&amp;quot;V&amp;quot;; break;
    }

    NSString *dateAndTime = [threadUnsafeDateFormatter stringFromDate:(logMessage-&amp;gt;_timestamp)];
    NSString *logMsg = logMessage-&amp;gt;_message;
    NSString *logFileNmae = logMessage -&amp;gt; _fileName;
    NSString *logFuncation = logMessage -&amp;gt; _function;
    long lineNum = logMessage -&amp;gt; _line;

    return [NSString stringWithFormat:@&amp;quot;%@ %@ :%li %@ %@ :::\n %@ &amp;quot;,logFileNmae, logFuncation,lineNum, logLevel, dateAndTime, logMsg];

}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;成果秀:43299706702588eefa55b6be9b7526b3&#34;&gt;成果秀&lt;/h3&gt;

&lt;p&gt;最后放几张配置好的结果图秀&lt;/p&gt;

&lt;h4 id=&#34;xcode-输出台的日志:43299706702588eefa55b6be9b7526b3&#34;&gt;xcode 输出台的日志&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/cocoaLumberjack/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;文件日志-模拟器可以直接进入文件然后用-tail-f-查看:43299706702588eefa55b6be9b7526b3&#34;&gt;文件日志（模拟器可以直接进入文件然后用&lt;code&gt;tail -f&lt;/code&gt; 查看）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/cocoaLumberjack/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Android自动构建</title>
      <link>https://zllbird.github.io/2015/11/30/android%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Mon, 30 Nov 2015 22:25:24 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2015/11/30/android%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/</guid>
      <description>

&lt;h1 id=&#34;android自动构建发布实践:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;Android自动构建发布实践&lt;/h1&gt;

&lt;p&gt;首先声明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这主要不是讲教程，这是集成过程中遇到的坑！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这主要不是讲教程，这是集成过程中遇到的坑！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这主要不是讲教程，这是集成过程中遇到的坑！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;重要的事情说三遍。&lt;/p&gt;

&lt;h3 id=&#34;集成工具:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;集成工具&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;jenkins (CI)&lt;/li&gt;
&lt;li&gt;Git and GitLab(GitHub同理)&lt;/li&gt;
&lt;li&gt;Gradle (build 工具)&lt;/li&gt;
&lt;li&gt;fir （发布工具）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工具简单介绍一下，&lt;/p&gt;

&lt;p&gt;jenkins是现在比较主流的CI，也正是因此，上面的插件丰富，涵盖面也很广，更为重要的是，非常容易安装和配置，自然是首选。&lt;/p&gt;

&lt;p&gt;Git 版本管理工具，就不用了讲解了。jenkins同时支持svn。（还是建议大家早点转到git上）公司现在的版本管理使用的是gitlab，类似github(github的迷你版)。&lt;/p&gt;

&lt;p&gt;Gradle是现任Android构建，很是强大。至于grade配置，网上教程很多也很杂乱，建议大家跟随谷歌原版[Gradle 用户指南]()&lt;/p&gt;

&lt;p&gt;这里再推荐一篇，个人认为对Gradle解读很到位的一篇文章。[深入理解gradle]()&lt;/p&gt;

&lt;h3 id=&#34;开始集成:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;开始集成&lt;/h3&gt;

&lt;p&gt;安装jenkins。&lt;/p&gt;

&lt;p&gt;如果你是mac或者Linux，可以直接通过shell安装（&lt;strong&gt;推荐&lt;/strong&gt; ）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install jenkins 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有brew，先安装Homebrew&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有ruby&amp;hellip; 请自行google。&lt;/p&gt;

&lt;p&gt;启动 Jenkins&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jenkins
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;访问-jenkins:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;访问 Jenkins&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;请在浏览器输入地址:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    http://localhost:8080/
  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用安装包安装后会自动打开，如果端口冲突那么请修改端口&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    defaults write /Library/Preferences/org.jenkins-ci httpPort xxxx
  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jenkins最基本的安装就完成了。然后，可以在浏览器输入地址查看一下。看到这样的画面，基本安装就完成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/initjenkins.png&#34; alt=&#34;initjenkins&#34; /&gt;&lt;/p&gt;

&lt;p&gt;截图里包含两个，一个是通过web端浏览器访问得到的界面。另一个是shell的日志。&lt;/p&gt;

&lt;p&gt;jenkins到此结束。开始使用jenkins，Android的构建之旅吧。&lt;/p&gt;

&lt;h3 id=&#34;jenkins的插件安装:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;jenkins的插件安装&lt;/h3&gt;

&lt;p&gt;两种方式。这里以安装Git插件为例。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过查询安装。&lt;/li&gt;
&lt;li&gt;通过自行下载*.hpi , 然后通过高级安装。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选择系统管理，然后选择管理插件。 &lt;img src=&#34;https://zllbird.github.io/images/jenkins/initpulgin.png&#34; alt=&#34;initpulgin&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;查询安装:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;查询安装。&lt;/h4&gt;

&lt;p&gt;在插件管理界面，选择可选插件，然后在右边过滤器里筛选Git或GIT plugin&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinsgit.png&#34; alt=&#34;jenkinsgit&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后选择立刻安装。&lt;/p&gt;

&lt;h4 id=&#34;自行下载-hpi-然后通过高级安装:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;自行下载*.hpi , 然后通过高级安装&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinscuston.png&#34; alt=&#34;jenkinscuston&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后选择上传。&lt;/p&gt;

&lt;h4 id=&#34;遇到的坑:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;遇到的坑&lt;/h4&gt;

&lt;p&gt;可以说刚开始我是一只使用第一种方法来安装插件的。结果失败率非常高。如果不自备梯子，失败率会更高！&lt;/p&gt;

&lt;p&gt;&lt;em&gt;折腾了很长时间，而且搞得自己心里憔悴。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;所以建议大家通过自己去jenkins的官网或镜像来下载hpi文件自行安装需要的插件。&lt;/p&gt;

&lt;p&gt;还有，自备梯子是一种好习惯。&lt;/p&gt;

&lt;h4 id=&#34;需要安装的插件:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;需要安装的插件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;Gitlab&lt;/li&gt;
&lt;li&gt;Gitlab Hook (我一直安装不成功，所以自动push event 构建也还未成功)&lt;/li&gt;
&lt;li&gt;Gradle&lt;/li&gt;
&lt;li&gt;fir （官网有详尽的&lt;a href=&#34;http://blog.fir.im/jenkins/&#34;&gt;下载和安装教程&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到此为止，所有的环境都准备好了。终于可以开动了！&lt;/p&gt;

&lt;h3 id=&#34;自动化构建实例:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;自动化构建实例&lt;/h3&gt;

&lt;p&gt;jenkins中新建一个项目，命名后，选择 &lt;code&gt;构建一个自由风格的软件项目&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;项目名称。&lt;strong&gt;跳过&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;描述。&lt;strong&gt;跳过&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;… 各种跳过，直接进入源码管理。&lt;/p&gt;

&lt;h4 id=&#34;源码管理:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;源码管理&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinssource.png&#34; alt=&#34;jenkinssource&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里选的是Git，当然如果你只有现实svn的话，那就是你还没安装Git的插件，具体安装请看上文。&lt;/p&gt;

&lt;p&gt;记住选择构建的分支。（这里是一个只含一个界面调试的项目，所以我直接用了master。&lt;strong&gt;建议，创建一个deploy发布或者debug这样的分支&lt;/strong&gt;，确保每次构建都是可控的。）&lt;/p&gt;

&lt;p&gt;注意到Credentials，这是身份验证。这里直接写了none，也就是说，没有直接验证身份。难道说，我的项目没加任何限制？？？&lt;/p&gt;

&lt;p&gt;当然，不是啦。Git的项目，无论是Github还是自己搭建的Gitlab，大多数都是通过ssh验证的。&lt;/p&gt;

&lt;p&gt;可以点击Credentials 后面的Add 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinsssh.png&#34; alt=&#34;jenkinsssh&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样保证jenkins部署的机器的ssh私钥在服务上。&lt;/p&gt;

&lt;h4 id=&#34;构建触发器:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;构建触发器&lt;/h4&gt;

&lt;p&gt;这就是传说中的&lt;strong&gt;自动构建&lt;/strong&gt;。直接上图讲解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinsauto.png&#34; alt=&#34;jenkinsauto&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里有三种事件触发构建。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Build periodically 。 即定时触发，这里我写的是&lt;code&gt;H 10 * * *&lt;/code&gt;，指的就是每天10点触发构建，也就是说，每天10天无论有没有新的代码部署，都会进行构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  H 10 * * *
  分 小时 天 月 年
  
  // 五位分别指向轮询事件，这里H 和 0 差不多意思，就是不顾及 分，每天10天构建。
  // * 指忽视
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Build when a change is pushed to GitLab. GitLab CI Service UR… 。这是Gitlab的插件，是gitlab通过事件通知的形式发放。（我测试了很久，感觉这个插件时好时坏，不建议使用）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poll SCM。 即轮询查询仓库中的代码是否有更新，如果有更新，则进行构建。没有更新，则忽视。这里写的&lt;code&gt;H/5 * * * *&lt;/code&gt;，指每五分钟进行代码扫描。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;H/5  指每五分钟。 这种写法指每这段时间进行轮询
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;构建:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;构建&lt;/h4&gt;

&lt;p&gt;构建栏中，选增加构建步骤。选择&lt;code&gt;Invoke Gradle script&lt;/code&gt;，当然，如果没有这个选项，就是未安装Gradle插件，然后具体的参数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinsbuild.png&#34; alt=&#34;jenkinsbuild&#34; /&gt;&lt;/p&gt;

&lt;p&gt;熟悉Gradle的，很容易看明白，只是执行了了gradle clean build 指令而已。不熟悉的也没关系，我会单独再写一篇关于优化Gradle在安卓上面的部署的 ，以及Gradle使用。&lt;/p&gt;

&lt;h4 id=&#34;构建后操作:8595cf9f458882a0b67b0f8cac9fde62&#34;&gt;构建后操作&lt;/h4&gt;

&lt;p&gt;我这里使用的是fir.im （做的还不错哦）。&lt;/p&gt;

&lt;p&gt;选择增加构建后操作步奏，选择&lt;code&gt;Upload to fir.im&lt;/code&gt;。 &lt;img src=&#34;https://zllbird.github.io/images/jenkins/jenkinsfir.png&#34; alt=&#34;jenkinsfir&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Token 需要注册fir后生成。&lt;/p&gt;

&lt;p&gt;IPA/APK Files ,是可选项。如果不填写，会直接从目录里找。如果填写了，则是会找到需要的目录。&lt;/p&gt;

&lt;p&gt;其他的涉及到测试等方面。不是本文涉及的内容。&lt;/p&gt;

&lt;p&gt;以上全部内容都是在自己mac上执行完成的。&lt;/p&gt;

&lt;p&gt;接下来在Linux上部署。&lt;/p&gt;

&lt;p&gt;到此构建基本完成。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>日出</title>
      <link>https://zllbird.github.io/2015/11/26/%E6%97%A5%E5%87%BA/</link>
      <pubDate>Thu, 26 Nov 2015 12:57:43 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2015/11/26/%E6%97%A5%E5%87%BA/</guid>
      <description>

&lt;h1 id=&#34;日出:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;日出&lt;/h1&gt;

&lt;h4 id=&#34;5-20:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt; 5:20。&lt;/h4&gt;

&lt;p&gt;又一次被梦折磨醒后，望着窗外已经破晓了的天空，我放弃了继续猫在被窝的打算…&lt;/p&gt;

&lt;p&gt;倚在窗前，望着天际。我莫名的有种想看日出的冲动，这种想法一旦冒出便遏制不住。我望了一眼桌子上的钟，5:23。很好，我觉得还不算太坏。现在骑车赶到海边应该还能看到，我开始急忙的收拾行头，准备出发。&lt;/p&gt;

&lt;p&gt;刚穿好衣服，一个念头撞进脑子里。今天天气有日出吗？我急忙拿出手机——阴转多云…&lt;/p&gt;

&lt;p&gt;我心凉了一大截，我又一次走到窗边，看着天际压得很深很深的雾霭，我害怕了。我开始犹豫，开始盘算出去能见到日出的可能性…&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&#34;5-28:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;5:28。&lt;/h4&gt;

&lt;p&gt;正当我心神彷徨的时候，我又一次被时间惊醒——5:28。我意识到，我如果再犹豫下去那么和我重新钻进被窝是等价的。然后我问了自己两个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我想看日出吗？&lt;/li&gt;
&lt;li&gt;现在去还来得及吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后，我便拿上钥匙出门了。出门前，我随手带了一件外套。到海边后我发觉我的随手是多么的明智。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&#34;5-38:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;5:38。&lt;/h4&gt;

&lt;p&gt;我一路飙车来到海边，当我看到灰蒙蒙的天际的时候，我才恍然我来早了。不过还好，能见度已经非常高了，海岸线上也有着零零散散晨练的老人。&lt;/p&gt;

&lt;p&gt;海风不大，但很凉。我倚在栏杆上怔怔出神，遥遥的望着那头的灯塔。&lt;img src=&#34;https://zllbird.github.io/images/sun/sun520.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-40:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;5:40。&lt;/h4&gt;

&lt;p&gt;我又忍不住想去灯塔那里看日出。我急忙用手机查了一下今早日出的时间，5:56。&lt;/p&gt;

&lt;p&gt;我看了一眼手机，又看了一眼灯塔。然后，骑上车，加速…&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun540.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-52:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;5:52.&lt;/h4&gt;

&lt;p&gt;当到达灯塔下的时候，我突然很骄傲。望着那已经泛红的天际，心中满是喜悦。&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun552.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-00:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:00&lt;/h4&gt;

&lt;p&gt;我在灯塔旁的亭子里默然的望着早已红透的天空。&lt;/p&gt;

&lt;p&gt;但，厚实的云黑压压的盖住了地平线，似乎在嘲笑我的愚蠢和荒唐。&lt;/p&gt;

&lt;p&gt;天越来越亮，能见度也越来越高。&lt;/p&gt;

&lt;p&gt;但…&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun600.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-10:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:10&lt;/h4&gt;

&lt;p&gt;天际的红晕也渐渐的褪去了，大海湛蓝湛蓝的，那么深邃，也那么冷清。&lt;/p&gt;

&lt;p&gt;我仍坐在亭子上遥望着东方。&lt;/p&gt;

&lt;p&gt;心有不甘，但却不愿承认这不甘。因为不愿承认自己已经无可奈何的错过…&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun610.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-13:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:13&lt;/h4&gt;

&lt;p&gt;我推着车，安安静静的走下亭子。&lt;/p&gt;

&lt;p&gt;然后，围着灯塔转了一圈又一圈。我开始思考我一早到现在的荒唐行径。&lt;/p&gt;

&lt;p&gt;前两天晚上，我笑话狐狸。估计狐狸看完后，也会笑话我…&lt;/p&gt;

&lt;p&gt;其实，也不必太在意。&lt;strong&gt;人生嘛，就是笑笑别人，然后，再让别人笑笑。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我转过头，又一次凝视着云层。带着那份没捡到日光海岸的失落，骑车驶向西方…&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun613.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-17:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:17&lt;/h4&gt;

&lt;p&gt;猛地被一阵惊呼声惊醒，我急忙转过头。深红色的太阳，在云层里挣扎网上挣脱。&lt;/p&gt;

&lt;p&gt;海岸上的所有人都偏过头看着东方。而太阳也似乎在努力地宣言，证明自己的存在。&lt;/p&gt;

&lt;p&gt;它似乎卖力的挤出云层就是想告诉我，你错了。&lt;/p&gt;

&lt;p&gt;我笑了笑，回答道：是的，我错了。你一直存在，只是我没看到而已。&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun617.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-20:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:20&lt;/h4&gt;

&lt;p&gt;太阳终于要挣脱云层，而此刻的海也别切成两边。西边是蔚蓝，东方泛着橘红。&lt;/p&gt;

&lt;p&gt;我突然明白为什么那么多人迫切的追求尼康，因为单单用语言的确描绘的那么生涩而无力。&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun620.jpg&#34; alt=&#34;&#34; /&gt;&lt;img src=&#34;https://zllbird.github.io/images/sun/sun621.jpg&#34; alt=&#34;&#34; /&gt;&lt;img src=&#34;https://zllbird.github.io/images/sun/sun622.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-30:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:30&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;我们都曾经有过无数的选择，到最后的都是各自性格的宿命。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但请坚信各自都会到达对的地方，只要为我们的方向奋不顾身过，用尽全力。我们都为我们各自的收获付出了代价，不要羡慕也不要自卑，请每一天，更喜欢自己一些，或者说，每一天，都向着自己所崇拜的人，前进一点。&lt;/p&gt;

&lt;p&gt; &lt;img src=&#34;https://zllbird.github.io/images/sun/sun630.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-35:b7b50ec8d4c4b22a378a46c6e304ed09&#34;&gt;6:35&lt;/h4&gt;

&lt;p&gt;我们都在按照自己的方式努力地活着，不断的失望又不断的希望，或许有意义，或许根本没意义。但那样的自己不才是真真正正的自己，不卑微，也不混乱。&lt;/p&gt;

&lt;p&gt;至于我们到底往哪走，怎么走？&lt;/p&gt;

&lt;p&gt;终究只有自己明白，终究只能自己历经。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zllbird.github.io/images/sun/sun635.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只是，偶尔应该停下来，先看看这个世界。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>感想 我该如何成长</title>
      <link>https://zllbird.github.io/2015/11/25/%E6%84%9F%E6%83%B3-%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF/</link>
      <pubDate>Wed, 25 Nov 2015 09:25:11 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2015/11/25/%E6%84%9F%E6%83%B3-%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF/</guid>
      <description>

&lt;h1 id=&#34;感想-我该如何成长:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;感想-我该如何成长&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;我始终相信，优秀归根到底是自己的事儿，所以成长，归根到底，也是要靠自己。 ——飞鸟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几天前和一个朋友聊起学习，又被一阵吐槽。说是被老板压榨，没有时间学习，等等巴拉巴拉&amp;hellip;又突然想起一个同事，总是感慨总是被公司的业务羁绊，向业务妥协。便有了这篇感慨。&lt;/p&gt;

&lt;p&gt;然后，我很认真的问自己，我该如何成长？&lt;/p&gt;

&lt;p&gt;想明白这个问题之前，应该先想明白另一个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我到底想成为一个什么样子的人？&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;相信自己而不是相信依靠:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;相信自己而不是相信依靠&lt;/h3&gt;

&lt;p&gt;有个同事说起这么一番话，我直接抄过来了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在思路上, 技术大牛确实给了很多启发, 甚至可以说不是技术细节的启发, 对我来说都是颠覆性的想法, 这些思路靠自己研究, 并且又在业务迭代的压力下几乎是不可能的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我其实很承认这句话的。尤其是和一些优秀和专研的人聊天，往往听完后，第一感觉就是听君一席话，胜读十年书啊。（当然，不仅仅局限技术大牛。）&lt;/p&gt;

&lt;p&gt;可惜的是，倾听我准备好了，求教我也准备好了，该准备的都准备好了。正所谓万事俱备，只缺一个技术大牛。&lt;/p&gt;

&lt;p&gt;好吧，有能指点的技术大牛是幸运的。但如果没有，其实也没那么糟糕。因为这个时代不仅不缺技术大牛，而且大牛们都还很喜欢分享。想想中国古代的老师傅们，总要留一手，不让本事全被徒弟学去了，而如今的大牛们，恨不得把自己的会的全都拿出来让你看看。&lt;strong&gt;（我一直庆幸自己能在这样一个时代里去拼搏&lt;/strong&gt;。）&lt;/p&gt;

&lt;p&gt;所以金山银山颜如玉神马的都有，只不过那些让你醍醐灌顶的指点都散落在网络上各处，只不过这次是需要你自己去找。&lt;/p&gt;

&lt;p&gt;我想说的是，不要去依赖，如果非要依赖，也只能依赖自己，相信自己。&lt;/p&gt;

&lt;h3 id=&#34;有捷径请走捷径-如果没有-请更加努力:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;有捷径请走捷径，如果没有，请更加努力&lt;/h3&gt;

&lt;p&gt;不得不承认，有人带着学习或者成长，会比自己摸石过河要快很多，少犯错，少走路。我是一个捷径主义者，所以，那些所谓打基础啊，吃亏是福啊，这是一种锻炼啊之类的话，我都认为是扯淡。&lt;/p&gt;

&lt;p&gt;聊点题外话，中学化学有一种推断ABCDEF是什么物质的题，大概是下面这个样子。每次做这种题，我都直接把出现最多的字母当成O，氧气。或者遇到无色透明液体，我直接就写成水。然后再一推断，一两分钟就能解决这个题。这个方法我从初三一路用到高考都不带失手的。捷径这么好用，为啥不用呢。&lt;/p&gt;

&lt;p&gt;聊完题外。回来说说，如果真没有人带，需要自己摸黑，走一步算一步的时候，我只能说。请更加努力，请更加劳苦，虽没有捷径可走，但至少还可以多付出。&lt;/p&gt;

&lt;h3 id=&#34;完美这个伪命题:357074d4ca6df4026eb17ea49d9f28f4&#34;&gt;完美这个伪命题&lt;/h3&gt;

&lt;p&gt;从小在做生意的人堆里长大，所以听到被人说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;只是单纯而简单的钻研技术, 把每个模块每个函数写到自己觉得完美.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样的话。我就很不舒服。在我心里大概有这么一个评级，不足，足够，优秀，完美。而我呢，是一个追求优秀，但忌惮完美的人。我潜意识里，完美等于巨大的物力，人力，财力，以及时间，一句话——高额成本！一旦遇到高额成本，我就会吓得慌。&lt;/p&gt;

&lt;p&gt;也怪我太贪心，不够专注。或者猎奇心太重，总想着尝试新的技术，新的东西，新的领域。所以，在我看来去追求完美，真的太浪费了。不是有句名言这么说的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不追求完美，何尝不是一种放下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;刚开始学习JAVA的时候，对各种设计模式学习，那叫一个如此如醉，奉若神技。但随着时间慢慢过去，现在反倒觉得那么多设计模式，何尝不是一种累赘。一方面，写出的代码怎么看都觉得有那么点相似，另一方面，有一种变相的冗长。再后来，接触了javascript，python等后，（现在学习Go中），越发着发觉，所谓的设计模式，本质上是Java语言本身的内建不够啊。&lt;/p&gt;

&lt;p&gt;想明白这点后，设计模式就再也不神秘了。好像又写的有点跑题了，回到完美这个梗。Java本身是有缺陷的，所以已阻止了完美的步伐，或者这样说：用Java写了一个&lt;strong&gt;完美的&lt;/strong&gt;方法，模块。但这种完美却很脆弱。脆弱到，一不小心，被时代淘汰了。&lt;/p&gt;

&lt;p&gt;时代太快了，快的让我不敢只专注于一项技巧与一种语言。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android自定义属性使用</title>
      <link>https://zllbird.github.io/2015/11/23/android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 23 Nov 2015 16:49:45 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2015/11/23/android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8/</guid>
      <description>

&lt;h1 id=&#34;android自定义属性使用以及注意事项:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;Android自定义属性使用以及注意事项&lt;/h1&gt;

&lt;p&gt;自定义控件和自定义属性是安卓开发过程中实现个性化的一个很好技巧，也是对sdk中UI部分的使用更加灵活的部分。这部分主要实现自定义属性，自定义控件的文档正在完善中。&lt;/p&gt;

&lt;h3 id=&#34;如何实现:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;如何实现：&lt;/h3&gt;

&lt;h4 id=&#34;a-在配置文件中声明:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;a) 在配置文件中声明。&lt;/h4&gt;

&lt;p&gt;虽说在value中哪个文件里都是一样（保证在resources标签下就行)，但作为一个有志向的开发者，良好的文件管理习惯是必须的，so，在values中创建一个名为：&lt;code&gt;attrs.xml&lt;/code&gt;来统一管理自定义属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;resources&amp;gt;
  &amp;lt;declare-styleable name=&amp;quot;ImageTextView&amp;quot;&amp;gt;
        &amp;lt;attr name=&amp;quot;select_src&amp;quot; format=&amp;quot;reference&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;normal_src&amp;quot; format=&amp;quot;reference&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;select_text_color&amp;quot; format=&amp;quot;color&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;normal_text_color&amp;quot; format=&amp;quot;color&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;image_text_padding&amp;quot; format=&amp;quot;dimension&amp;quot;/&amp;gt;
        &amp;lt;attr name=&amp;quot;android:textSize&amp;quot;/&amp;gt;
        &amp;lt;attr name=&amp;quot;android:layout_gravity&amp;quot; /&amp;gt;
        &amp;lt;attr name=&amp;quot;android:text&amp;quot; /&amp;gt;
    &amp;lt;/declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义属性的声明是通过子标签&lt;code&gt;declare-styleable&lt;/code&gt;声明了大的样式，具体的属性是通过&lt;code&gt;attr&lt;/code&gt;来声明，声明包含属性名和格式（具体是属性值的格式，一般有reference，color，integer，float，dimension，boolean，string等，当然还有enum，如果是枚举的话要继续声明具体的枚举），如果对于自定义控件来说，某些属性就是已经android声明的属性，就可以在&lt;code&gt;name&lt;/code&gt;后面直接写明使用android：声明的哪个属性（简单吧）。&lt;/p&gt;

&lt;h4 id=&#34;b-在自定义控件xml中使用:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;b) 在自定义控件xml中使用&lt;/h4&gt;

&lt;p&gt;（主要是讲解自定义属性，所以这里的自定义控件较为简单，就是一个imageview + textview的组合）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;com.android.lesdo.view.UpImageTextView
	//声明使用app来定义自定义属性名，当然这个命名是你确定的。
    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    android:id=&amp;quot;@+id/iv&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text = &amp;quot;Hello&amp;quot;
    android:textSize = &amp;quot;14sp&amp;quot;
    android:layout_marginRight=&amp;quot;59dp&amp;quot;
    // 使用刚才已经在arrts里声明好的属性
    app:select_src = &amp;quot;@drawable/searchuser_t_pressed&amp;quot; 
    app:normal_src = &amp;quot;@drawable/searchuser_t_normal&amp;quot;
    app:select_text_color = &amp;quot;@color/green&amp;quot;
    app:normal_text_color = &amp;quot;@color/content&amp;quot;
    app:image_text_padding = &amp;quot;7dp&amp;quot;
    /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以声明android本来的属性，一样可以使用（具体在自定义控件里说明）。&lt;/p&gt;

&lt;h4 id=&#34;c-在自定义控件-java类-中读取属性使用:3bdf756234a6e48d25bbfd7dc8dacd4b&#34;&gt;c) 在自定义控件（java类）中读取属性使用&lt;/h4&gt;

&lt;p&gt;最后的使用。&lt;/p&gt;

&lt;p&gt;自定义控件大多数要继承原本的&lt;code&gt;Imageview&lt;/code&gt; ，&lt;code&gt;TextView&lt;/code&gt; ，&lt;code&gt;FrameLayout&lt;/code&gt;等，当然直接继承View也是一样的，只不过直接继承View和ViewGroup的灵活性太高，一般用不到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public UpImageTextView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    // 加载布局文件
    LayoutInflater.from(context).inflate(R.layout.down_text_image,this);
        imageView = (ImageView) findViewById(R.id.image);
        textView = (TextView) findViewById(R.id.text);

    // 获取属性集
  	// 这里获取的就是我们再res 下value中声明的ImageTextView属性集
  	// 当然是由IDE自动在R文件中生成的。
        final TypedArray a = context.obtainStyledAttributes(
                attrs, R.styleable.ImageTextView);

    // 通过声明的format 就可以定向获取到属性
  	// R.styleable 都是自动生成的，具体属性名都是跟在声明的style名字后面的
  	// R.styleable.ImageTextView_normal_src对应的就是 arrts.xml中的
  	// &amp;lt;attr name=&amp;quot;normal_src&amp;quot; format=&amp;quot;reference&amp;quot; /&amp;gt;

       int selectRes = a.getResourceId(R.styleable.ImageTextView_select_src,0);
       int normalRes = a.getResourceId(R.styleable.ImageTextView_normal_src,0);
       int selectTextColor = a.getResourceId(R.styleable.ImageTextView_select_text_color,R.color.green);
       int normalTextColor = a.getResourceId(R.styleable.ImageTextView_normal_text_color, R.color.title);
      int textSize = a.getDimensionPixelSize(R.styleable.ImageTextView_android_textSize, 0);
        int image_text_padding = a.getDimensionPixelOffset(R.styleable.ImageTextView_image_text_padding,0);
        String text = a.getString(R.styleable.ImageTextView_android_text);

        a.recycle();
        imageView.setImageResource(normalRes);
        textView.setTextColor(getResources().getColor(normalTextColor));
        textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
        textView.setText(text);
        textView.setPadding(0,image_text_padding,0,0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依次获取属性，然后使用。弹药注意的是，获取完自定义或者本身的属性后，一定要将&lt;code&gt;final TypedArray a&lt;/code&gt;返回到用之前的状态，可以看到&lt;code&gt;TypedArray&lt;/code&gt;是context中获取的，它是一个环境中统一使用的，所以用完记得要还。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; a.recycle();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的坑：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; int textSize = a.getDimensionPixelSize(R.styleable.ImageTextView_android_textSize, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里获取的 ，单位是&lt;strong&gt;sp&lt;/strong&gt;得值 ，单位是&lt;strong&gt;sp&lt;/strong&gt;得值 ，单位是&lt;strong&gt;sp&lt;/strong&gt;得值！！！&lt;/p&gt;

&lt;p&gt;所以使用的时候记得加上&lt;code&gt;TypedValue&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android Transition 学习心得</title>
      <link>https://zllbird.github.io/2015/11/12/android-transition-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</link>
      <pubDate>Thu, 12 Nov 2015 15:40:32 +0800</pubDate>
      
      <guid>https://zllbird.github.io/2015/11/12/android-transition-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</guid>
      <description>

&lt;h1 id=&#34;android-transition-学习心得:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Android Transition 学习心得&lt;/h1&gt;

&lt;p&gt;Android 5.0之后。Transition 被更多的应用起来，support也对其越来越多得支持。这种大背景下，各种动画的学习便是必不可少的了。而其中Transition便是其中的佼佼者。&lt;/p&gt;

&lt;p&gt;下面是比较详细的介绍和应用实践，我也是主要通过这个项目学习，但强烈建议，只先通看文档，别上来直接就照着写（还有看完后，记得回来啊！！！）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lgvalle/Material-Animations&#34;&gt;Material-Animations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看完后，我那叫一个心血澎湃。但按住心情，现在才是真正意义上的开始学习。&lt;/p&gt;

&lt;p&gt;我学习的过程，大概分以下几部分，可以做个参考，也非常欢迎大家的质疑和讨论。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先运行Demo或者Examples代码，运行结果ok后，认真研读代码。&lt;em&gt;我始终认为，读一个轻量，但完整的工程代码，是快速学习的最有效的途径&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;对关键API(类和方法)的学习。&lt;em&gt;知其然，也必须，知其所以然&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;尝试代码。&lt;em&gt;写代码千万不要粘贴，千万不要忘记配置文件，android中千万不要忘记style等&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;activity跳转:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Activity跳转&lt;/h3&gt;

&lt;h4 id=&#34;1-activity跳转都是需要添加-window-属性:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;1)Activity跳转都是需要添加&lt;code&gt;window&lt;/code&gt;属性。&lt;/h4&gt;

&lt;p&gt;配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;style name=&amp;quot;MaterialAnimations&amp;quot; parent=&amp;quot;@style/Theme.AppCompat.Light.NoActionBar&amp;quot;&amp;gt;
  ...
  //添加window开启Transtions动画属性
  &amp;lt;item name=&amp;quot;android:windowContentTransitions&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt; 

  //是否覆盖执行，其实可以理解成是否同步执行还是顺序执行
  &amp;lt;item name=&amp;quot;android:windowAllowEnterTransitionOverlap&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
  &amp;lt;item name=&amp;quot;android:windowAllowReturnTransitionOverlap&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
  ...
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以直接在代码里写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过不建议在代码里写，因为现在使用Support v7 比较多，所以，不是直接原生的Activity，会又很多莫名其妙的错误。&lt;/p&gt;

&lt;h4 id=&#34;2-配置进出动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;2)配置进出动画&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void setupWindowAnimations() {
    // Re-enter transition is executed when returning to this activity
    Slide slideTransition = new Slide();
    slideTransition.setSlideEdge(Gravity.LEFT);
 slideTransition.setDuration(getResources().getInteger(R.integer.anim_duration_long));
    getWindow().setReenterTransition(slideTransition); // 5.0以后的方法
    getWindow().setExitTransition(slideTransition); // 5.0以后的方法
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-启动页面跳转:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;3)启动页面跳转&lt;/h4&gt;

&lt;p&gt;这里需要注意的跳转的时候&lt;strong&gt;一定一定一定&lt;/strong&gt;要配置ActivityOption。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 配置这个option必不可少
ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity,view,shareName);
startActivity(intent,options.toBundle());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，现在用support已经成为主流，下面是v4提供的支持类，用法相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 配置这个option必不可少
ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity,view,shareName);
startActivity(intent,options.toBundle());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，基本Activity的跳转就实现了。官方提供了三种实践，&lt;strong&gt;Explode&lt;/strong&gt;, &lt;strong&gt;Slide&lt;/strong&gt; 和&lt;strong&gt;Fade&lt;/strong&gt;，分别是上下拉开，上下左右滑入滑出，以及淡出淡入等。&lt;/p&gt;

&lt;h3 id=&#34;shareelement共享元素:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;ShareElement共享元素&lt;/h3&gt;

&lt;p&gt;不同界面的相同元素，进行跳转的时候，共联跳转，看起来简直是舒服到不行。也是我学习TransitionAnimation最大的动力。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lgvalle/Material-Animations&#34;&gt;Material-Animations&lt;/a&gt;中有非常详细的介绍实现。&lt;/p&gt;

&lt;p&gt;我整体试了一下，发觉使用&lt;code&gt;Fragment&lt;/code&gt;比使用&lt;code&gt;Activity&lt;/code&gt;动画不仅连贯很多，而且整体感更强。而且，&lt;code&gt;Fragment&lt;/code&gt;的API对Transtion更加的亲善。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Transition for fragment1
Slide slideTransition = new Slide(Gravity.LEFT); 
slideTransition.setDuration(getResources().getInteger(R.integer.anim_duration_long));
// Create fragment and define some of it transitions
SharedElementFragment1 sharedElementFragment1 = SharedElementFragment1.newInstance(sample);
// 下面这几个方法都是Fragment的方法，可见Google已经建议使用Fragment，进行共享元素跳转是相当好的体验
sharedElementFragment1.setReenterTransition(slideTransition); 
sharedElementFragment1.setExitTransition(slideTransition);
sharedElementFragment1.setSharedElementEnterTransition(new ChangeBounds());

getSupportFragmentManager().beginTransaction()
        .replace(R.id.sample2_content, sharedElementFragment1)
        .commit();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google建议，使用Fragment去承载UI界面，Activity主要承载操作Fragment。因此，关于跳转，也强烈建议使用上面的实践。&lt;/p&gt;

&lt;h3 id=&#34;view动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;View动画&lt;/h3&gt;

&lt;h4 id=&#34;scenes:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Scenes&lt;/h4&gt;

&lt;p&gt;在一个界面内（Activity or Fragment）实现动画，就需要&lt;code&gt;scenes&lt;/code&gt;，这个scene，翻译成视图，结果图都觉得很别扭，我就这么解释，scene是一种静态或者结果状态，就是最后是啥样子的。如果是位移动画，相当于初始位置的图，和运动完后的位置图。然后由，&lt;code&gt;TransitionManager&lt;/code&gt;最后调用，go方法，他就跑起来了。&lt;/p&gt;

&lt;p&gt;详细请看项目中的&lt;code&gt;AnimationsActivity2&lt;/code&gt;类，核心代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cene1 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene1, this);
scene2 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene2, this);
scene3 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene3, this);
scene4 = Scene.getSceneForLayout(sceneRoot, R.layout.activity_animations_scene4, this);

View button1 = findViewById(R.id.sample3_button1);
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene1, new ChangeBounds());
    }
});
View button2 = findViewById(R.id.sample3_button2);
button2.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene2, TransitionInflater.from(AnimationsActivity2.this).inflateTransition(R.transition.slide_and_changebounds));
    }
});

View button3 = findViewById(R.id.sample3_button3);
button3.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene3, TransitionInflater.from(AnimationsActivity2.this).inflateTransition(R.transition.slide_and_changebounds_sequential));
    }
});

View button4 = findViewById(R.id.sample3_button4);
button4.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        TransitionManager.go(scene4, TransitionInflater.from(AnimationsActivity2.this).inflateTransition(R.transition.slide_and_changebounds_sequential_with_interpolators));
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;view-属性改变引起的动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;View 属性改变引起的动画&lt;/h4&gt;

&lt;p&gt;这个就有点变态了，你更改了空间的layout属性，告诉Transtion一声，他就做成动画反馈在界面上。听起来就很叼！&lt;/p&gt;

&lt;p&gt;实现起来非常非常的简单，简单到想哭。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void changeLayout() {

  // 声明，由Transition接管界面变化的意思，这里的viewRoot相当于根视图，
  // 也就是说，想改变layout布局的view,父类要先被接管
    TransitionManager.beginDelayedTransition(viewRoot);

    ViewGroup.LayoutParams params = square.getLayoutParams();
    if (sizeChanged) {
        params.width = savedWidth;
    } else {
        savedWidth = params.width;
        params.width = 200;
    }
    sizeChanged = !sizeChanged;
    square.setLayoutParams(params);
}

private void changePosition() {
    TransitionManager.beginDelayedTransition(viewRoot);

    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) square.getLayoutParams();
    if (positionChanged) {
        lp.gravity = Gravity.CENTER;
    } else {
        lp.gravity = Gravity.LEFT;
    }
    positionChanged = !positionChanged;
    square.setLayoutParams(lp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信，介于此，5.0后的android上很多用户体验能提升一大截。&lt;/p&gt;

&lt;h3 id=&#34;reveal-揭示动画:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;Reveal，揭示动画&lt;/h3&gt;

&lt;p&gt;这也是相当符合设计一种动画，通过一点引发触动（可以是接触点，也可以位移后触动），然后由点及面，揭示（展现）内容。&lt;/p&gt;

&lt;p&gt;一般都是通过shared elements一起组合使用，完成界面跳转。&lt;/p&gt;

&lt;p&gt;Circular Reveal 即通过原点，然后由点及面逐步揭示，而且还有一个弧度，视觉体验感非常好。&lt;/p&gt;

&lt;p&gt;这里要用到&lt;code&gt;ViewAnimationUtils&lt;/code&gt;类（这个类里承载了很多动画，非常还用!）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 揭示原点，这里的点取的是控件的中点
int cx = (viewRoot.getLeft() + viewRoot.getRight()) / 2;
int cy = (viewRoot.getTop() + viewRoot.getBottom()) / 2;
int finalRadius = Math.max(viewRoot.getWidth(), viewRoot.getHeight()); // 揭示弧度

// 获得动画
Animator anim = ViewAnimationUtils.createCircularReveal(viewRoot, cx, cy, 0, finalRadius);

// 这里更改动画，是为了看到的揭示能比较清楚
viewRoot.setBackgroundColor(color);
anim.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        animateButtonsIn();
    }
});
anim.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不是由控件引起的，而是由点击（其实就是触摸）引起的，只需要传入接触点的x,y坐标就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public boolean onTouch(View view, MotionEvent motionEvent) {
    if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
        if (view.getId() == R.id.square_yellow) {
            revealFromCoordinates(motionEvent.getRawX(), motionEvent.getRawY());
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Animator animateRevealColorFromCoordinates(int x, int y) {

    float finalRadius = (float) Math.hypot(viewRoot.getWidth(), viewRoot.getHeight());

    Animator anim = ViewAnimationUtils.createCircularReveal(viewRoot, x, y, 0, finalRadius);
    viewRoot.setBackgroundColor(color);
    anim.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刚才提到的改变layout属性，就可以改变动画其实也是可以用到圆揭示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Transition transition = TransitionInflater.from(this).inflateTransition(R.transition.changebounds_with_arcmotion);
transition.addListener(new Transition.TransitionListener() {
    @Override
    public void onTransitionEnd(Transition transition) {
        animateRevealColor(bgViewGroup, R.color.red);
    }
    (...)

});
//接管后，传入想要改变的动画
TransitionManager.beginDelayedTransition(bgViewGroup, transition);
RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT);
btnRed.setLayoutParams(layoutParams);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;总结:197eea1a2f41ae8a1e21912c062e6b04&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;写的比较简单，很多东西还是对API的熟悉和使用。&lt;/p&gt;

&lt;p&gt;Material 正在改变Android，相信以后的UI无论从实感还是物理感，都会更加贴合用户，贴近使用。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>